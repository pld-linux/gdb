--- /dev/null	2008-05-02 23:36:22.370004160 +0200
+++ gdb-6.8/gdb/testsuite/gdb.base/gcore-shmid0.exp	2008-05-03 22:36:56.000000000 +0200
@@ -0,0 +1,120 @@
+# Copyright 2007 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gdb@prep.ai.mit.edu
+
+# Test GDB's handling of gcore for mapping with a name but zero inode.
+
+set testfile "gcore-shmid0"
+set srcfile  ${testfile}.c
+set binfile  ${objdir}/${subdir}/${testfile}
+
+if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
+     untested gcore.exp
+     return -1
+}
+
+# Start with a fresh gdb.
+
+gdb_exit
+gdb_start
+gdb_reinitialize_dir $srcdir/$subdir
+gdb_load ${binfile}
+
+# Does this gdb support gcore?
+send_gdb "help gcore\n"
+gdb_expect {
+    -re "Undefined command: .gcore.*$gdb_prompt $" {
+	# gcore command not supported -- nothing to test here.
+	unsupported "gdb does not support gcore on this target"
+	return -1;
+    }
+    -re "Save a core file .*$gdb_prompt $" {
+	pass "help gcore"
+    }
+    -re ".*$gdb_prompt $" {
+	fail "help gcore"
+    }
+    timeout {
+	fail "help gcore (timeout)"
+    }
+}
+
+if { ! [ runto_main ] } then {
+    untested gcore-shmid0.exp
+    return -1
+}
+
+gdb_breakpoint "initialized"
+gdb_breakpoint "unresolved"
+
+set test "Continue to initialized."
+gdb_test_multiple "continue" $test {
+    -re "Breakpoint .*, initialized .* at .*\r\n$gdb_prompt $" {
+	pass $test
+    }
+    -re "Breakpoint .*, unresolved .* at .*\r\n$gdb_prompt $" {
+	unsupported $test
+	return -1
+    }
+}
+
+set escapedfilename [string_to_regexp ${objdir}/${subdir}/gcore-shmid0.test]
+
+set test "save a corefile"
+gdb_test_multiple "gcore ${objdir}/${subdir}/gcore-shmid0.test" $test {
+    -re "Saved corefile ${escapedfilename}\[\r\n\]+$gdb_prompt $" {
+	pass $test
+    }
+    -re "Can't create a corefile\[\r\n\]+$gdb_prompt $" {
+	unsupported $test
+    }
+    eof {
+	fail $test
+    }
+}
+
+# Be sure to remove the handle first.
+# But it would get removed even on a kill by GDB as the handle is already
+# deleted, just it is still attached.
+gdb_continue_to_end "finish"
+
+set test "core-file command"
+gdb_test_multiple "core-file $objdir/$subdir/gcore-shmid0.test" $test {
+    -re ".* program is being debugged already.*y or n. $" {
+	# gdb_load may connect us to a gdbserver.
+	send_gdb "y\n"
+	exp_continue;
+    }
+    -re "Core was generated by .*\r\n\#0  .*\\\(\\\).*\r\n$gdb_prompt $" {
+	# The filename does not fit there anyway so do not check it.
+	pass $test
+    }
+    -re ".*registers from core file: File in wrong format.* $" {
+	fail "core-file command (could not read registers from core file)"
+    }
+}
+
+set test "backtrace"
+gdb_test_multiple "bt" $test {
+    -re "#0 *initialized \\\(\\\) at .*#1 .* main \\\(.*$gdb_prompt $" {
+	pass $test
+    }
+    -re "#0 *initialized \\\(\\\) at .*Cannot access memory at address .*$gdb_prompt $" {
+	fail $test
+    }
+}
--- /dev/null	2008-05-02 23:36:22.370004160 +0200
+++ gdb-6.8/gdb/testsuite/gdb.base/gcore-shmid0.c	2008-05-03 22:39:10.000000000 +0200
@@ -0,0 +1,95 @@
+/* Copyright 2007 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or (at
+   your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ * Test GDB's handling of gcore for mapping with a name but zero inode.
+ */
+
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <assert.h>
+
+/* We need a backtrace through the stack.  */
+
+static void
+initialized (void)
+{
+}
+
+static void
+unresolved (void)
+{
+}
+
+int
+main (void)
+{
+  int sid;
+  unsigned int *addr = (void *) -1L;
+  int try;
+
+  /* The generated SID will cycle with an increment of 32768, try until it
+   * wraps to 0.  */
+
+  for (try = 0; addr == (void *) -1L; try++)
+    {
+      /* At least kernel-2.6.25-8.fc9.x86_64 just never returns the value 0 by
+         shmget(2).  */
+      if (try > 0x10000)
+        {
+	  printf ("Problem no longer reproducible on this kernel (try %d)\n",
+		  try);
+	  unresolved ();
+	  exit (1);
+	}
+
+      sid = shmget ((key_t) rand (), 0x1000, IPC_CREAT | IPC_EXCL | 0777);
+      if (sid == -1)
+	{
+	  printf ("shmget (%d, 0x1000, IPC_CREAT): errno %d\n", 0, errno);
+	  exit (1);
+	}
+
+      /* Use SID only if it is 0, retry it otherwise.  */
+
+      if (sid == 0)
+	{
+	  addr = shmat (sid, NULL, SHM_RND);
+	  if (addr == (void *) -1L)
+	    {
+	      printf ("shmat (%d, NULL, SHM_RND): errno %d\n", sid,
+		      errno);
+	      exit (1);
+	    }
+	}
+      if (shmctl (sid, IPC_RMID, NULL) != 0)
+	{
+	  printf ("shmctl (%d, IPC_RMID, NULL): errno %d\n", sid, errno);
+	  exit (1);
+	}
+    }
+
+  initialized ();
+
+  return 0;
+}
