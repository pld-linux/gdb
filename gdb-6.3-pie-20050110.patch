2007-11-02  Jan Kratochvil  <jan.kratochvil@redhat.com>

	Port to GDB-6.7.1.

2007-11-02  Jan Kratochvil  <jan.kratochvil@redhat.com>

	Port to post-GDB-6.7.1 multi-PC breakpoints.

2007-11-09  Jan Kratochvil  <jan.kratochvil@redhat.com>

	* solib-svr4.c (svr4_current_sos): Fix segfault on NULL EXEC_BFD.

2008-02-24  Jan Kratochvil  <jan.kratochvil@redhat.com>

	Port to GDB-6.8pre.

2008-02-27  Jan Kratochvil  <jan.kratochvil@redhat.com>

	Port to gdb-6.7.50.20080227.

2008-06-01  Jan Kratochvil  <jan.kratochvil@redhat.com>

	Fix crash on a watchpoint update on an inferior stop.

2008-09-01  Jan Kratochvil  <jan.kratochvil@redhat.com>

	Fix scan_dyntag() for binaries provided by valgrind (BZ 460319).

Index: gdb-6.8.50.20090302/gdb/amd64-tdep.c
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/amd64-tdep.c	2009-03-07 00:30:09.000000000 +0100
+++ gdb-6.8.50.20090302/gdb/amd64-tdep.c	2009-03-07 00:30:12.000000000 +0100
@@ -36,6 +36,7 @@
 #include "regcache.h"
 #include "regset.h"
 #include "symfile.h"
+#include "exceptions.h"
 
 #include "gdb_assert.h"
 
@@ -1586,16 +1587,28 @@ amd64_analyze_stack_align (CORE_ADDR pc,
    Any function that doesn't start with this sequence will be assumed
    to have no prologue and thus no valid frame pointer in %rbp.  */
 
-static CORE_ADDR
-amd64_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
-			struct amd64_frame_cache *cache)
+struct amd64_analyze_prologue_data
+  {
+    CORE_ADDR pc, current_pc;
+    struct amd64_frame_cache *cache;
+    CORE_ADDR retval;
+  };
+
+static int
+amd64_analyze_prologue_1 (void *data_pointer)
 {
+  struct amd64_analyze_prologue_data *data = data_pointer;
+  CORE_ADDR pc = data->pc, current_pc = data->current_pc;
+  struct amd64_frame_cache *cache = data->cache;
   static gdb_byte proto[3] = { 0x48, 0x89, 0xe5 }; /* movq %rsp, %rbp */
   gdb_byte buf[3];
   gdb_byte op;
 
   if (current_pc <= pc)
-    return current_pc;
+    {
+      data->retval = current_pc;
+      return 1;
+    }
 
   pc = amd64_analyze_stack_align (pc, current_pc, cache);
 
@@ -1610,18 +1623,57 @@ amd64_analyze_prologue (CORE_ADDR pc, CO
 
       /* If that's all, return now.  */
       if (current_pc <= pc + 1)
-        return current_pc;
+        {
+	  data->retval = current_pc;
+	  return 1;
+        }
 
       /* Check for `movq %rsp, %rbp'.  */
       read_memory (pc + 1, buf, 3);
       if (memcmp (buf, proto, 3) != 0)
-	return pc + 1;
+	{
+	  data->retval = pc + 1;
+	  return 1;
+	}
 
       /* OK, we actually have a frame.  */
       cache->frameless_p = 0;
-      return pc + 4;
+      data->retval = pc + 4;
+      return 1;
     }
 
+  data->retval = pc;
+  return 1;
+}
+
+/* Catch memory read errors and return just PC in such case.
+   It occurs very early on enable_break->new_symfile_objfile->
+   ->breakpoint_re_set->decode_line_1->decode_variable_1->
+   ->find_function_start_sal  */
+
+static CORE_ADDR
+amd64_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
+			struct amd64_frame_cache *cache)
+{
+  int status;
+  struct amd64_analyze_prologue_data data;
+  struct ui_file *saved_gdb_stderr;
+
+  /* Suppress error messages.  */
+  saved_gdb_stderr = gdb_stderr;
+  gdb_stderr = ui_file_new ();
+
+  data.pc = pc;
+  data.current_pc = current_pc;
+  data.cache = cache;
+  status = catch_errors (amd64_analyze_prologue_1, &data, "", RETURN_MASK_ALL);
+
+  /* Stop suppressing error messages.  */
+  ui_file_delete (gdb_stderr);
+  gdb_stderr = saved_gdb_stderr;
+
+  if (status)
+    return data.retval;
   return pc;
 }
 
Index: gdb-6.8.50.20090302/gdb/auxv.c
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/auxv.c	2009-03-07 00:30:06.000000000 +0100
+++ gdb-6.8.50.20090302/gdb/auxv.c	2009-03-07 00:30:12.000000000 +0100
@@ -81,7 +81,7 @@ procfs_xfer_auxv (struct target_ops *ops
    Return 1 if an entry was read into *TYPEP and *VALP.  */
 static int
 default_auxv_parse (struct target_ops *ops, gdb_byte **readptr,
-		   gdb_byte *endptr, CORE_ADDR *typep, CORE_ADDR *valp)
+		   gdb_byte *endptr, ULONGEST *typep, CORE_ADDR *valp)
 {
   const int sizeof_auxv_field = gdbarch_ptr_bit (target_gdbarch)
 				/ TARGET_CHAR_BIT;
@@ -108,7 +108,7 @@ default_auxv_parse (struct target_ops *o
    Return 1 if an entry was read into *TYPEP and *VALP.  */
 int
 target_auxv_parse (struct target_ops *ops, gdb_byte **readptr,
-                  gdb_byte *endptr, CORE_ADDR *typep, CORE_ADDR *valp)
+                  gdb_byte *endptr, ULONGEST *typep, CORE_ADDR *valp)
 {
   struct target_ops *t;
   for (t = ops; t != NULL; t = t->beneath)
@@ -123,9 +123,10 @@ target_auxv_parse (struct target_ops *op
    an error getting the information.  On success, return 1 after
    storing the entry's value field in *VALP.  */
 int
-target_auxv_search (struct target_ops *ops, CORE_ADDR match, CORE_ADDR *valp)
+target_auxv_search (struct target_ops *ops, ULONGEST match, CORE_ADDR *valp)
 {
-  CORE_ADDR type, val;
+  CORE_ADDR val;
+  ULONGEST at_type;
   gdb_byte *data;
   LONGEST n = target_read_alloc (ops, TARGET_OBJECT_AUXV, NULL, &data);
   gdb_byte *ptr = data;
@@ -135,10 +136,10 @@ target_auxv_search (struct target_ops *o
     return n;
 
   while (1)
-    switch (target_auxv_parse (ops, &ptr, data + n, &type, &val))
+    switch (target_auxv_parse (ops, &ptr, data + n, &at_type, &val))
       {
       case 1:			/* Here's an entry, check it.  */
-	if (type == match)
+	if (at_type == match)
 	  {
 	    xfree (data);
 	    *valp = val;
@@ -161,7 +162,8 @@ target_auxv_search (struct target_ops *o
 int
 fprint_target_auxv (struct ui_file *file, struct target_ops *ops)
 {
-  CORE_ADDR type, val;
+  CORE_ADDR val;
+  ULONGEST at_type;
   gdb_byte *data;
   LONGEST len = target_read_alloc (ops, TARGET_OBJECT_AUXV, NULL,
 				   &data);
@@ -171,13 +173,13 @@ fprint_target_auxv (struct ui_file *file
   if (len <= 0)
     return len;
 
-  while (target_auxv_parse (ops, &ptr, data + len, &type, &val) > 0)
+  while (target_auxv_parse (ops, &ptr, data + len, &at_type, &val) > 0)
     {
       const char *name = "???";
       const char *description = "";
       enum { dec, hex, str } flavor = hex;
 
-      switch (type)
+      switch (at_type)
 	{
 #define TAG(tag, text, kind) \
 	case tag: name = #tag; description = text; flavor = kind; break
@@ -232,7 +234,7 @@ fprint_target_auxv (struct ui_file *file
 	}
 
       fprintf_filtered (file, "%-4s %-20s %-30s ",
-			plongest (type), name, description);
+			plongest (at_type), name, description);
       switch (flavor)
 	{
 	case dec:
@@ -254,7 +256,7 @@ fprint_target_auxv (struct ui_file *file
 	  break;
 	}
       ++ents;
-      if (type == AT_NULL)
+      if (at_type == AT_NULL)
 	break;
     }
 
Index: gdb-6.8.50.20090302/gdb/auxv.h
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/auxv.h	2009-01-03 06:57:50.000000000 +0100
+++ gdb-6.8.50.20090302/gdb/auxv.h	2009-03-07 00:30:12.000000000 +0100
@@ -36,14 +36,14 @@ struct target_ops;		/* Forward declarati
    Return 1 if an entry was read into *TYPEP and *VALP.  */
 extern int target_auxv_parse (struct target_ops *ops,
 			      gdb_byte **readptr, gdb_byte *endptr,
-			      CORE_ADDR *typep, CORE_ADDR *valp);
+			      ULONGEST *typep, CORE_ADDR *valp);
 
 /* Extract the auxiliary vector entry with a_type matching MATCH.
    Return zero if no such entry was found, or -1 if there was
    an error getting the information.  On success, return 1 after
    storing the entry's value field in *VALP.  */
 extern int target_auxv_search (struct target_ops *ops,
-			       CORE_ADDR match, CORE_ADDR *valp);
+			       ULONGEST match, CORE_ADDR *valp);
 
 /* Print the contents of the target's AUXV on the specified file. */
 extern int fprint_target_auxv (struct ui_file *file, struct target_ops *ops);
Index: gdb-6.8.50.20090302/gdb/breakpoint.c
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/breakpoint.c	2009-03-07 00:30:10.000000000 +0100
+++ gdb-6.8.50.20090302/gdb/breakpoint.c	2009-03-07 00:30:12.000000000 +0100
@@ -3920,7 +3920,8 @@ describe_other_breakpoints (CORE_ADDR pc
 	      printf_filtered (" (thread %d)", b->thread);
 	    printf_filtered ("%s%s ",
 			     ((b->enable_state == bp_disabled || 
-			       b->enable_state == bp_call_disabled) 
+			       b->enable_state == bp_call_disabled ||
+			       b->enable_state == bp_startup_disabled)
 			      ? " (disabled)"
 			      : b->enable_state == bp_permanent 
 			      ? " (permanent)"
@@ -5008,6 +5009,61 @@ create_catchpoint (int tempflag, char *c
   return b;
 }
 
+void
+disable_breakpoints_at_startup (int silent)
+{
+  struct breakpoint *b;
+  int disabled_startup_breaks = 0;
+
+  if (bfd_get_start_address (exec_bfd) != entry_point_address ())
+    {
+      ALL_BREAKPOINTS (b)
+	{
+	  if (((b->type == bp_breakpoint) ||
+	       (b->type == bp_hardware_breakpoint)) &&
+	      b->enable_state == bp_enabled &&
+	      !b->loc->duplicate)
+	    {
+	      b->enable_state = bp_startup_disabled;
+	      if (!silent)
+		{
+		  if (!disabled_startup_breaks)
+		    {
+		      target_terminal_ours_for_output ();
+		      warning ("Temporarily disabling breakpoints:");
+		    }
+		  disabled_startup_breaks = 1;
+		  warning ("breakpoint #%d addr 0x%s", b->number, paddr_nz(b->loc->address));
+		}
+	    }
+	}
+    }
+}
+
+/* Try to reenable any breakpoints after startup.  */
+void
+re_enable_breakpoints_at_startup (void)
+{
+  struct breakpoint *b;
+
+  if (bfd_get_start_address (exec_bfd) != entry_point_address ())
+    {
+      ALL_BREAKPOINTS (b)
+	if (b->enable_state == bp_startup_disabled)
+	  {
+	    char buf[1];
+
+	    /* Do not reenable the breakpoint if the shared library
+	       is still not mapped in.  */
+	    if (target_read_memory (b->loc->address, buf, 1) == 0)
+	      {
+		/*printf ("enabling breakpoint at 0x%s\n", paddr_nz(b->loc->address));*/
+		b->enable_state = bp_enabled;
+	      }
+	  }
+    }
+}
+
 static void
 create_fork_vfork_event_catchpoint (int tempflag, char *cond_string,
                                     struct breakpoint_ops *ops)
Index: gdb-6.8.50.20090302/gdb/breakpoint.h
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/breakpoint.h	2009-03-07 00:30:06.000000000 +0100
+++ gdb-6.8.50.20090302/gdb/breakpoint.h	2009-03-07 00:30:12.000000000 +0100
@@ -127,6 +127,7 @@ enum enable_state
 			   automatically enabled and reset when the call 
 			   "lands" (either completes, or stops at another 
 			   eventpoint). */
+    bp_startup_disabled,
     bp_permanent	/* There is a breakpoint instruction hard-wired into
 			   the target's code.  Don't try to write another
 			   breakpoint instruction on top of it, or restore
@@ -847,6 +848,10 @@ extern void remove_thread_event_breakpoi
 
 extern void disable_breakpoints_in_shlibs (void);
 
+extern void disable_breakpoints_at_startup (int silent);
+
+extern void re_enable_breakpoints_at_startup (void);
+
 /* This function returns TRUE if ep is a catchpoint. */
 extern int ep_is_catchpoint (struct breakpoint *);
 
Index: gdb-6.8.50.20090302/gdb/dwarf2read.c
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/dwarf2read.c	2009-03-07 00:30:10.000000000 +0100
+++ gdb-6.8.50.20090302/gdb/dwarf2read.c	2009-03-07 00:30:12.000000000 +0100
@@ -1413,7 +1413,7 @@ dwarf2_build_psymtabs (struct objfile *o
   else
     dwarf2_per_objfile->loc_buffer = NULL;
 
-  if (mainline
+  if ((mainline == 1)
       || (objfile->global_psymbols.size == 0
 	  && objfile->static_psymbols.size == 0))
     {
Index: gdb-6.8.50.20090302/gdb/elfread.c
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/elfread.c	2009-03-07 00:30:06.000000000 +0100
+++ gdb-6.8.50.20090302/gdb/elfread.c	2009-03-07 00:30:12.000000000 +0100
@@ -680,7 +680,7 @@ elf_symfile_read (struct objfile *objfil
   /* If we are reinitializing, or if we have never loaded syms yet,
      set table to empty.  MAINLINE is cleared so that *_read_psymtab
      functions do not all also re-initialize the psymbol table. */
-  if (mainline)
+  if (mainline == 1)
     {
       init_psymbol_list (objfile, 0);
       mainline = 0;
Index: gdb-6.8.50.20090302/gdb/infrun.c
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/infrun.c	2009-03-07 00:30:10.000000000 +0100
+++ gdb-6.8.50.20090302/gdb/infrun.c	2009-03-07 00:30:12.000000000 +0100
@@ -3354,6 +3354,11 @@ infrun: BPSTAT_WHAT_SET_LONGJMP_RESUME (
 #endif
 	  target_terminal_inferior ();
 
+	  /* For PIE executables, we dont really know where the
+	     breakpoints are going to be until we start up the
+	     inferior.  */
+          re_enable_breakpoints_at_startup ();
+
 	  /* If requested, stop when the dynamic linker notifies
 	     gdb of events.  This allows the user to get control
 	     and place breakpoints in initializer routines for
Index: gdb-6.8.50.20090302/gdb/objfiles.c
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/objfiles.c	2009-03-07 00:30:06.000000000 +0100
+++ gdb-6.8.50.20090302/gdb/objfiles.c	2009-03-07 00:30:12.000000000 +0100
@@ -51,6 +51,9 @@
 #include "arch-utils.h"
 #include "exec.h"
 
+#include "auxv.h"
+#include "elf/common.h"
+
 /* Prototypes for local functions */
 
 static void objfile_alloc_data (struct objfile *objfile);
@@ -271,7 +274,19 @@ init_entry_point_info (struct objfile *o
 CORE_ADDR
 entry_point_address (void)
 {
-  return symfile_objfile ? symfile_objfile->ei.entry_point : 0;
+  int ret;
+  CORE_ADDR entry_addr;
+
+  /* Find the address of the entry point of the program from the
+     auxv vector.  */
+  ret = target_auxv_search (&current_target, AT_ENTRY, &entry_addr);
+  if (ret == 1)
+     return entry_addr;                                                                              
+  /*if (ret == 0 || ret == -1)*/
+  else
+    {
+      return symfile_objfile ? symfile_objfile->ei.entry_point : 0;
+    }
 }
 
 /* Create the terminating entry of OBJFILE's minimal symbol table.
@@ -443,6 +458,9 @@ free_objfile (struct objfile *objfile)
   if (objfile == rt_common_objfile)
     rt_common_objfile = NULL;
 
+  if (objfile == symfile_objfile)
+    symfile_objfile = NULL;
+
   /* Before the symbol table code was redone to make it easier to
      selectively load and remove information particular to a specific
      linkage unit, gdb used to do these things whenever the monolithic
Index: gdb-6.8.50.20090302/gdb/solib-svr4.c
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/solib-svr4.c	2009-03-07 00:30:09.000000000 +0100
+++ gdb-6.8.50.20090302/gdb/solib-svr4.c	2009-03-07 00:30:12.000000000 +0100
@@ -45,6 +45,7 @@
 #include "exec.h"
 #include "auxv.h"
 #include "exceptions.h"
+#include "command.h"
 
 static struct link_map_offsets *svr4_fetch_link_map_offsets (void);
 static int svr4_have_link_map_offsets (void);
@@ -287,7 +288,9 @@ static CORE_ADDR main_lm_addr;
 
 /* Local function prototypes */
 
+#if 0
 static int match_main (char *);
+#endif
 
 static CORE_ADDR bfd_lookup_symbol (bfd *, char *);
 
@@ -521,10 +524,12 @@ scan_dyntag (int dyntag, bfd *abfd, CORE
   int arch_size, step, sect_size;
   long dyn_tag;
   CORE_ADDR dyn_ptr, dyn_addr;
+  CORE_ADDR reloc_addr = 0;
   gdb_byte *bufend, *bufstart, *buf;
   Elf32_External_Dyn *x_dynp_32;
   Elf64_External_Dyn *x_dynp_64;
   struct bfd_section *sect;
+  int ret;
 
   if (abfd == NULL)
     return 0;
@@ -532,19 +537,81 @@ scan_dyntag (int dyntag, bfd *abfd, CORE
   if (arch_size == -1)
    return 0;
 
+  /* The auxv vector based relocatable files reading is limited to the main
+     executable.  */
+  gdb_assert (abfd == exec_bfd || ptr == NULL);
+
+  if (ptr != NULL)
+    {
+      CORE_ADDR entry_addr;
+
+      /* Find the address of the entry point of the program from the
+	 auxv vector.  */
+      ret = target_auxv_search (&current_target, AT_ENTRY, &entry_addr);
+
+      if (ret == 0 || ret == -1)
+	{
+	  /* No auxv info, maybe an older kernel. Fake our way through.  */
+	  entry_addr = bfd_get_start_address (exec_bfd); 
+
+	  if (debug_solib)
+	    fprintf_unfiltered (gdb_stdlog,
+				"elf_locate_base: program entry address not found. Using bfd's 0x%s for %s\n",
+				paddr_nz (entry_addr), exec_bfd->filename);
+	}
+      else
+	{
+	  if (debug_solib)
+	    fprintf_unfiltered (gdb_stdlog,
+				"elf_locate_base: found program entry address 0x%s for %s\n",
+				paddr_nz (entry_addr), exec_bfd->filename);
+	}
+      reloc_addr = entry_addr - bfd_get_start_address (exec_bfd);
+      if (debug_solib)
+	fprintf_unfiltered (gdb_stdlog,
+			    "elf_locate_base: expected relocation offset 0x%s for %s\n",
+			    paddr_nz (reloc_addr), exec_bfd->filename);
+    }
+
   /* Find the start address of the .dynamic section.  */
   sect = bfd_get_section_by_name (abfd, ".dynamic");
   if (sect == NULL)
-    return 0;
+    { 
+      if (debug_solib)
+	fprintf_unfiltered (gdb_stdlog,
+			    "elf_locate_base: .dynamic section not found in %s -- return now\n",
+			    exec_bfd->filename);
+      return 0;
+    }
+  else
+    { 
+      if (debug_solib)
+	fprintf_unfiltered (gdb_stdlog,
+			    "elf_locate_base: .dynamic section found in %s\n",
+			    exec_bfd->filename);
+    }
+
   dyn_addr = bfd_section_vma (abfd, sect);
+  if (debug_solib)
+    fprintf_unfiltered (gdb_stdlog,
+			"elf_locate_base: .dynamic addr 0x%s\n",
+			paddr_nz (dyn_addr));
 
   /* Read in .dynamic from the BFD.  We will get the actual value
      from memory later.  */
   sect_size = bfd_section_size (abfd, sect);
   buf = bufstart = alloca (sect_size);
+  if (debug_solib) 
+    fprintf_unfiltered (gdb_stdlog, 
+                        "elf_locate_base: read in .dynamic section\n");
   if (!bfd_get_section_contents (abfd, sect,
 				 buf, 0, sect_size))
-    return 0;
+    { 
+      if (debug_solib)
+	fprintf_unfiltered (gdb_stdlog,
+			    "elf_locate_base: couldn't read .dynamic section -- return now\n");
+      return 0;
+    }
 
   /* Iterate over BUF and scan for DYNTAG.  If found, set PTR and return.  */
   step = (arch_size == 32) ? sizeof (Elf32_External_Dyn)
@@ -565,26 +632,105 @@ scan_dyntag (int dyntag, bfd *abfd, CORE
 	dyn_tag = bfd_h_get_64 (abfd, (bfd_byte *) x_dynp_64->d_tag);
 	dyn_ptr = bfd_h_get_64 (abfd, (bfd_byte *) x_dynp_64->d_un.d_ptr);
       }
-     if (dyn_tag == DT_NULL)
+
+    /* Verify RELOC_ADDR makes sense - it does not have to for valgrind which
+       supplies us a specially crafted executable in /proc/PID/fd/X while
+       /proc/PID/auxv corresponds to a different executable (.../memcheck).  */
+    if (reloc_addr)
+      {
+	gdb_byte tag_buf[8];
+	CORE_ADDR tag_addr;
+
+	tag_addr = dyn_addr + (buf - bufstart) + reloc_addr;
+	if (target_read_memory (tag_addr, tag_buf, arch_size / 8) == 0)
+	  {
+	    if (memcmp (tag_buf, buf, arch_size / 8) != 0)
+	      {
+		if (debug_solib)
+		  fprintf_unfiltered (gdb_stdlog,
+				      "elf_locate_base: tag at offset 0x%lx does not match,"
+				      " dropping relocation offset %s\n",
+				      (unsigned long) (buf - bufstart), paddr_nz (reloc_addr));
+		reloc_addr = 0;
+	      }
+	  }
+	else
+	  {
+	    if (debug_solib)
+	      fprintf_unfiltered (gdb_stdlog,
+				  "elf_locate_base: tag at offset 0x%lx is not readable,"
+				  " dropping relocation offset %s\n",
+				  (unsigned long) (buf - bufstart), paddr_nz (reloc_addr));
+	    reloc_addr = 0;
+	  }
+      }
+
+    if (dyn_tag == DT_NULL)
        return 0;
-     if (dyn_tag == dyntag)
-       {
-	 /* If requested, try to read the runtime value of this .dynamic
-	    entry.  */
-	 if (ptr)
-	   {
-	     struct type *ptr_type;
-	     gdb_byte ptr_buf[8];
-	     CORE_ADDR ptr_addr;
-
-	     ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
-	     ptr_addr = dyn_addr + (buf - bufstart) + arch_size / 8;
-	     if (target_read_memory (ptr_addr, ptr_buf, arch_size / 8) == 0)
-	       dyn_ptr = extract_typed_address (ptr_buf, ptr_type);
-	     *ptr = dyn_ptr;
-	   }
-	 return 1;
-       }
+    if (dyn_tag == dyntag)
+      {
+	/* If requested, try to read the runtime value of this .dynamic
+	   entry.  */
+	if (ptr)
+	  {
+	    gdb_byte ptr_buf[8];
+	    CORE_ADDR ptr_addr;
+	    int got;
+
+	    ptr_addr = dyn_addr + (buf - bufstart) + arch_size / 8;
+	    if (ptr != NULL)
+	      {
+		if (debug_solib)
+		  fprintf_unfiltered (gdb_stdlog,
+				      "elf_locate_base: unrelocated ptr addr 0x%s\n",
+				      paddr_nz (ptr_addr));
+		ptr_addr += reloc_addr;
+		if (debug_solib) 
+		  fprintf_unfiltered (gdb_stdlog, 
+				      "elf_locate_base: relocated ptr addr 0x%s"
+				      " (relocation offset %s) for %s\n",
+				      paddr_nz (ptr_addr), paddr_nz (reloc_addr),
+				      exec_bfd->filename);
+	      }
+	    got = target_read_memory (ptr_addr, ptr_buf, arch_size / 8);
+	    if (got != 0 && reloc_addr)
+	      {
+		ptr_addr -= reloc_addr;
+		if (debug_solib) 
+		  fprintf_unfiltered (gdb_stdlog, 
+				      "elf_locate_base: unrelocated back to ptr addr 0x%s"
+				      " as the memory was unreable for %s\n",
+				      paddr_nz (ptr_addr), exec_bfd->filename);
+		got = target_read_memory (ptr_addr, ptr_buf, arch_size / 8);
+	      }
+
+	    if (got == 0)
+	      {
+		struct type *ptr_type;
+
+		ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
+		dyn_ptr = extract_typed_address (ptr_buf, ptr_type);
+		if (ptr != NULL)
+		  {
+		    if (debug_solib)
+		      fprintf_unfiltered (gdb_stdlog,
+					  "elf_locate_base: Tag entry has value 0x%s -- return now\n",
+					  paddr_nz (dyn_ptr));
+		  }
+	      }
+	    else
+	      {
+		if (ptr != NULL)
+		  {
+		    if (debug_solib)
+		      fprintf_unfiltered (gdb_stdlog,
+					  "elf_locate_base: Couldn't read tag entry value -- return now\n");
+		  }
+	      }
+	    *ptr = dyn_ptr;
+	  }
+	return 1;
+      }
   }
 
   return 0;
@@ -774,6 +920,10 @@ solib_svr4_r_map (void)
   struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();
   struct type *ptr_type = builtin_type (target_gdbarch)->builtin_data_ptr;
 
+  if (debug_solib)
+    fprintf_unfiltered (gdb_stdlog, 
+                        "solib_svr4_r_map: read at 0x%s\n",
+                        paddr_nz (debug_base + lmo->r_map_offset));
   return read_memory_typed_address (debug_base + lmo->r_map_offset, ptr_type);
 }
 
@@ -945,6 +1095,11 @@ svr4_current_sos (void)
   struct so_list *head = 0;
   struct so_list **link_ptr = &head;
   CORE_ADDR ldsomap = 0;
+  const char *filename = exec_bfd ? exec_bfd->filename : "<none>";
+
+  if (debug_solib)
+    fprintf_unfiltered (gdb_stdlog, 
+                        "svr4_current_sos: exec_bfd %s\n", filename);
 
   /* Always locate the debug struct, in case it has moved.  */
   debug_base = 0;
@@ -953,10 +1108,19 @@ svr4_current_sos (void)
   /* If we can't find the dynamic linker's base structure, this
      must not be a dynamically linked executable.  Hmm.  */
   if (! debug_base)
-    return svr4_default_sos ();
+    {
+      if (debug_solib)
+	fprintf_unfiltered (gdb_stdlog, 
+			    "svr4_current_sos: no DT_DEBUG found in %s -- return now\n",
+			    filename);
+      return svr4_default_sos ();
+    }
 
   /* Walk the inferior's link map list, and build our list of
      `struct so_list' nodes.  */
+  if (debug_solib)
+    fprintf_unfiltered (gdb_stdlog, 
+			"svr4_current_sos: walk link map in %s\n", filename);
   lm = solib_svr4_r_map ();
 
   while (lm)
@@ -973,26 +1137,104 @@ svr4_current_sos (void)
       new->lm_info->lm = xzalloc (lmo->link_map_size);
       make_cleanup (xfree, new->lm_info->lm);
 
+      if (debug_solib)
+        fprintf_unfiltered (gdb_stdlog, 
+                            "svr4_current_sos: read lm at 0x%s\n", paddr_nz(lm));
       read_memory (lm, new->lm_info->lm, lmo->link_map_size);
 
       lm = LM_NEXT (new);
 
+      if (debug_solib)
+        fprintf_unfiltered (gdb_stdlog,
+                            "svr4_current_sos: is first link entry? %d\n",
+                            IGNORE_FIRST_LINK_MAP_ENTRY (new));
+
       /* For SVR4 versions, the first entry in the link map is for the
          inferior executable, so we must ignore it.  For some versions of
          SVR4, it has no name.  For others (Solaris 2.3 for example), it
          does have a name, so we can no longer use a missing name to
          decide when to ignore it. */
-      if (IGNORE_FIRST_LINK_MAP_ENTRY (new) && ldsomap == 0)
+      if (exec_bfd != NULL && IGNORE_FIRST_LINK_MAP_ENTRY (new) && ldsomap == 0)
 	{
-	  main_lm_addr = new->lm_info->lm_addr;
-	  free_so (new);
-	}
+          /* It is the first link map entry, i.e. it is the main executable.  */
+
+	  if (bfd_get_start_address (exec_bfd) == entry_point_address ())
+	    {
+	      /* Non-pie case, main executable has not been relocated.  */
+	      main_lm_addr = new->lm_info->lm_addr;
+	      free_so (new);
+	    }
+	  else
+	    {
+              /* Pie case, main executable has been relocated.  */
+	      struct so_list *gdb_solib;
+
+	      if (debug_solib)
+		fprintf_unfiltered (gdb_stdlog,
+				    "svr4_current_sos: Processing first link map entry\n");
+	      strncpy (new->so_name, exec_bfd->filename,
+		       SO_NAME_MAX_PATH_SIZE - 1);
+	      new->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
+	      strcpy (new->so_original_name, new->so_name);
+	      /*new->main = 1;*/
+	      new->main_relocated = 0;
+            
+	      if (debug_solib)
+		{ 
+		  fprintf_unfiltered (gdb_stdlog,
+				      "svr4_current_sos: Processing nameless DSO\n");
+		  fprintf_unfiltered (gdb_stdlog,
+				      "svr4_current_sos: adding name %s\n",
+				      new->so_name);
+		}
+
+	      for (gdb_solib = master_so_list ();
+                   gdb_solib;
+                   gdb_solib = gdb_solib->next)
+		{
+		  if (debug_solib)
+		    fprintf_unfiltered (gdb_stdlog,
+					"svr4_current_sos: compare gdb %s and new %s\n",
+					gdb_solib->so_name, new->so_name);
+		  if (strcmp (gdb_solib->so_name, new->so_name) == 0)
+		    if (gdb_solib->main_relocated)
+		      { 
+			if (debug_solib)
+			  fprintf_unfiltered (gdb_stdlog,
+					      "svr4_current_sos: found main relocated\n");
+			break;
+		      }
+		}
+
+	      if ((gdb_solib && !gdb_solib->main_relocated) || (!gdb_solib))
+		{
+		  add_to_target_sections (0 /*from_tty*/, &current_target, new);
+		  new->main = 1;
+		}
+
+	      /* We need this in the list of shared libs we return because
+		 solib_add_stub will loop through it and add the symbol file.  */
+	      new->next = 0;
+	      *link_ptr = new;
+	      link_ptr = &new->next; 
+	    }
+	} /* End of IGNORE_FIRST_LINK_MAP_ENTRY  */
       else
 	{
+          /* This is not the first link map entry, i.e. is not the main
+             executable.  Note however that it could be the DSO supplied on
+             certain systems (i.e. Linux 2.6) containing information about
+             the vsyscall page.  We must ignore such entry. This entry is 
+             nameless (just like the one for the main executable, sigh).  */
+
 	  int errcode;
 	  char *buffer;
 
 	  /* Extract this shared object's name.  */
+	  if (debug_solib)
+	    fprintf_unfiltered (gdb_stdlog, 
+                                "svr4_current_sos: read LM_NAME\n");
+
 	  target_read_string (LM_NAME (new), &buffer,
 			      SO_NAME_MAX_PATH_SIZE - 1, &errcode);
 	  if (errcode != 0)
@@ -1000,47 +1242,60 @@ svr4_current_sos (void)
 		     safe_strerror (errcode));
 	  else
 	    {
-	      struct build_id *build_id;
+	      if (debug_solib)
+		fprintf_unfiltered (gdb_stdlog, 
+				    "svr4_current_sos: LM_NAME is <%s>\n",
+				    buffer);
+	      /* The name could be empty, in which case it is the
+		 system supplied DSO.  */
+	      if (strcmp (buffer, "") == 0)
+		free_so (new);
+	      else
+		{
+		  struct build_id *build_id;
 
-	      strncpy (new->so_original_name, buffer, SO_NAME_MAX_PATH_SIZE - 1);
-	      new->so_original_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
-	      /* May get overwritten below.  */
-	      strcpy (new->so_name, new->so_original_name);
+		  strncpy (new->so_original_name, buffer, SO_NAME_MAX_PATH_SIZE - 1);
+		  new->so_original_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
+		  /* May get overwritten below.  */
+		  strcpy (new->so_name, new->so_original_name);
 
-	      build_id = build_id_addr_get (LM_DYNAMIC_FROM_LINK_MAP (new));
-	      if (build_id != NULL)
-		{
-		  char *name, *build_id_filename;
+		  build_id = build_id_addr_get (LM_DYNAMIC_FROM_LINK_MAP (new));
+		  if (build_id != NULL)
+		    {
+		      char *name, *build_id_filename;
+
+		      /* Missing the build-id matching separate debug info file
+			 would be handled while SO_NAME gets loaded.  */
+		      name = build_id_to_filename (build_id, &build_id_filename, 0);
+		      if (name != NULL)
+			{
+			  strncpy (new->so_name, name, SO_NAME_MAX_PATH_SIZE - 1);
+			  new->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
+			  xfree (name);
+			}
+		      else
+			debug_print_missing (new->so_name, build_id_filename);
+
+		      xfree (build_id_filename);
+		      xfree (build_id);
+		    }
 
-		  /* Missing the build-id matching separate debug info file
-		     would be handled while SO_NAME gets loaded.  */
-		  name = build_id_to_filename (build_id, &build_id_filename, 0);
-		  if (name != NULL)
+		  if (debug_solib)
 		    {
-		      strncpy (new->so_name, name, SO_NAME_MAX_PATH_SIZE - 1);
-		      new->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
-		      xfree (name);
+		      fprintf_unfiltered (gdb_stdlog, 
+					  "svr4_current_sos: Processing DSO: %s\n",
+					  new->so_name);
+		      fprintf_unfiltered (gdb_stdlog,
+					  "svr4_current_sos: first link entry %d\n",
+					  IGNORE_FIRST_LINK_MAP_ENTRY (new));
 		    }
-		  else
-		    debug_print_missing (new->so_name, build_id_filename);
 
-		  xfree (build_id_filename);
-		  xfree (build_id);
+		  new->next = 0;
+		  *link_ptr = new;
+		  link_ptr = &new->next;
 		}
 	    }
-	  xfree (buffer);
-
-	  /* If this entry has no name, or its name matches the name
-	     for the main executable, don't include it in the list.  */
-	  if (! new->so_name[0]
-	      || match_main (new->so_name))
-	    free_so (new);
-	  else
-	    {
-	      new->next = 0;
-	      *link_ptr = new;
-	      link_ptr = &new->next;
-	    }
+          xfree (buffer);
 	}
 
       /* On Solaris, the dynamic linker is not in the normal list of
@@ -1056,6 +1311,9 @@ svr4_current_sos (void)
   if (head == NULL)
     return svr4_default_sos ();
 
+  if (debug_solib)
+    fprintf_unfiltered (gdb_stdlog, "svr4_current_sos: ENDS %s\n", filename);
+
   return head;
 }
 
@@ -1087,7 +1345,7 @@ svr4_fetch_objfile_link_map (struct objf
 /* On some systems, the only way to recognize the link map entry for
    the main executable file is by looking at its name.  Return
    non-zero iff SONAME matches one of the known main executable names.  */
-
+#if 0
 static int
 match_main (char *soname)
 {
@@ -1101,6 +1359,7 @@ match_main (char *soname)
 
   return (0);
 }
+#endif
 
 /* Return 1 if PC lies in the dynamic symbol resolution code of the
    SVR4 run time loader.  */
@@ -1251,15 +1510,29 @@ enable_break (void)
   /* Find the program interpreter; if not found, warn the user and drop
      into the old breakpoint at symbol code.  */
   interp_name = find_program_interpreter ();
+
+  if (debug_solib)
+     fprintf_unfiltered (gdb_stdlog,
+                         "enable_break: search for .interp in %s\n",
+                         exec_bfd->filename);
   if (interp_name)
     {
       CORE_ADDR load_addr = 0;
+      CORE_ADDR load_addr_mask = -1L;
       int load_addr_found = 0;
       int loader_found_in_list = 0;
       struct so_list *so;
       bfd *tmp_bfd = NULL;
       struct target_ops *tmp_bfd_target;
       volatile struct gdb_exception ex;
+      int arch_size;
+
+      /* For 32bit inferiors with 64bit GDB we may get LOAD_ADDR at 0xff......
+	 and thus overflowing its addition to the address while CORE_ADDR is
+	 64bit producing 0x1........ address invalid across GDB.  */
+      arch_size = bfd_get_arch_size (exec_bfd);
+      if (arch_size > 0 && arch_size < sizeof (1UL) * 8)
+        load_addr_mask = (1UL << arch_size) - 1;
 
       sym_addr = 0;
 
@@ -1276,6 +1549,9 @@ enable_break (void)
         {
 	  tmp_bfd = solib_bfd_open (interp_name);
 	}
+      if (debug_solib)
+	 fprintf_unfiltered (gdb_stdlog,
+			    "enable_break: opening %s\n", interp_name);
       if (tmp_bfd == NULL)
 	goto bkpt_at_symbol;
 
@@ -1329,16 +1605,16 @@ enable_break (void)
       interp_sect = bfd_get_section_by_name (tmp_bfd, ".text");
       if (interp_sect)
 	{
-	  interp_text_sect_low =
-	    bfd_section_vma (tmp_bfd, interp_sect) + load_addr;
+	  interp_text_sect_low = (bfd_section_vma (tmp_bfd, interp_sect)
+				  + load_addr) & load_addr_mask;
 	  interp_text_sect_high =
 	    interp_text_sect_low + bfd_section_size (tmp_bfd, interp_sect);
 	}
       interp_sect = bfd_get_section_by_name (tmp_bfd, ".plt");
       if (interp_sect)
 	{
-	  interp_plt_sect_low =
-	    bfd_section_vma (tmp_bfd, interp_sect) + load_addr;
+	  interp_plt_sect_low = (bfd_section_vma (tmp_bfd, interp_sect)
+				 + load_addr) & load_addr_mask;
 	  interp_plt_sect_high =
 	    interp_plt_sect_low + bfd_section_size (tmp_bfd, interp_sect);
 	}
@@ -1373,7 +1649,11 @@ enable_break (void)
 
       if (sym_addr != 0)
 	{
-	  create_solib_event_breakpoint (load_addr + sym_addr);
+	  create_solib_event_breakpoint ((load_addr + sym_addr)
+					 & load_addr_mask);
+	  if (debug_solib)
+	    fprintf_unfiltered (gdb_stdlog,
+			       "enable_break: solib bp set\n");
 	  xfree (interp_name);
 	  return 1;
 	}
@@ -1639,6 +1919,8 @@ svr4_solib_create_inferior_hook (void)
   while (tp->stop_signal != TARGET_SIGNAL_TRAP);
   inf->stop_soon = NO_STOP_QUIETLY;
 #endif /* defined(_SCO_DS) */
+
+   disable_breakpoints_at_startup (1);
 }
 
 static void
@@ -1820,6 +2102,75 @@ svr4_lp64_fetch_link_map_offsets (void)
 
   return lmp;
 }
+void
+info_linkmap_command (char *cmd, int from_tty)
+{
+  CORE_ADDR lm;
+                                                                                
+  /* Make sure we've looked up the inferior's dynamic linker's base
+     structure.  */
+  if (! debug_base)
+    {
+      debug_base = locate_base ();
+                                                                                
+      /* If we can't find the dynamic linker's base structure, this
+         must not be a dynamically linked executable.  Hmm.  */
+      if (! debug_base)
+        {
+          if (debug_solib)
+            fprintf_unfiltered (gdb_stdlog,
+                                "svr4_print_linkmap: no DT_DEBUG found in %s -- return now\n",
+                                exec_bfd->filename);
+          return;
+        }
+    }
+                                                                                
+  /* Walk the inferior's link map list, and print the info.  */
+ 
+  lm = solib_svr4_r_map ();
+  while (lm)
+    {
+      int errcode;
+      char *buffer;
+      CORE_ADDR load_addr;
+
+      struct link_map_offsets *lmo = svr4_fetch_link_map_offsets ();
+      struct so_list *new
+        = (struct so_list *) xmalloc (sizeof (struct so_list));
+      struct cleanup *old_chain = make_cleanup (xfree, new);
+
+      memset (new, 0, sizeof (*new));
+
+      new->lm_info = xmalloc (sizeof (struct lm_info));
+      make_cleanup (xfree, new->lm_info);
+
+      new->lm_info->lm = xmalloc (lmo->link_map_size);
+      make_cleanup (xfree, new->lm_info->lm);
+      memset (new->lm_info->lm, 0, lmo->link_map_size);
+
+      if (debug_solib)
+        fprintf_unfiltered (gdb_stdlog,
+                            "svr4_print_linkmap: read lm at 0x%s\n", paddr_nz(lm));
+      read_memory (lm, new->lm_info->lm, lmo->link_map_size);
+
+      lm = LM_NEXT (new);
+
+      /* Load address.  */
+      load_addr = LM_ADDR_CHECK (new, NULL);
+      /* Shared object's name.  */
+      target_read_string (LM_NAME (new), &buffer,
+			  SO_NAME_MAX_PATH_SIZE - 1, &errcode);
+      make_cleanup (xfree, buffer);
+      if (errcode != 0)
+	{
+	  warning ("svr4_print_linkmap: Can't read pathname for load map: %s\n",
+		   safe_strerror (errcode));
+	}
+      fprintf_filtered (gdb_stdout, "%-8s %-30s\n", paddr(load_addr), buffer);
+      do_cleanups (old_chain);
+    }
+}                                                                                
+
 
 
 struct target_so_ops svr4_so_ops;
@@ -1859,4 +2210,7 @@ _initialize_svr4_solib (void)
   svr4_so_ops.in_dynsym_resolve_code = svr4_in_dynsym_resolve_code;
   svr4_so_ops.lookup_lib_global_symbol = elf_lookup_lib_symbol;
   svr4_so_ops.same = svr4_same;
+
+  add_info ("linkmap", info_linkmap_command,
+	    "Display the inferior's linkmap.");
 }
Index: gdb-6.8.50.20090302/gdb/solib.c
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/solib.c	2009-02-21 17:14:49.000000000 +0100
+++ gdb-6.8.50.20090302/gdb/solib.c	2009-03-07 00:30:12.000000000 +0100
@@ -81,6 +81,8 @@ set_solib_ops (struct gdbarch *gdbarch, 
 
 /* external data declarations */
 
+int debug_solib;
+
 /* FIXME: gdbarch needs to control this variable, or else every
    configuration needs to call set_solib_ops.  */
 struct target_so_ops *current_target_so_ops;
@@ -104,6 +106,8 @@ The search path for loading non-absolute
 		    value);
 }
 
+void add_to_target_sections (int, struct target_ops *, struct so_list *);
+
 /*
 
    GLOBAL FUNCTION
@@ -426,10 +430,23 @@ free_so (struct so_list *so)
       
   if (so->abfd)
     {
-      bfd_filename = bfd_get_filename (so->abfd);
-      if (! bfd_close (so->abfd))
-	warning (_("cannot close \"%s\": %s"),
-		 bfd_filename, bfd_errmsg (bfd_get_error ()));
+      struct objfile *objfile;
+
+      ALL_OBJFILES (objfile)
+	if (objfile->obfd == so->abfd)
+	  {
+	    gdb_assert (objfile->flags & OBJF_KEEPBFD);
+	    objfile->flags &= ~OBJF_KEEPBFD;
+	    break;
+	  }
+
+      if (!objfile)
+	{
+	  bfd_filename = bfd_get_filename (so->abfd);
+	  if (! bfd_close (so->abfd))
+	    warning (_("cannot close \"%s\": %s"),
+		     bfd_filename, bfd_errmsg (bfd_get_error ()));
+	}
     }
 
   if (bfd_filename)
@@ -460,15 +477,40 @@ symbol_add_stub (void *arg)
   /* Have we already loaded this shared object?  */
   ALL_OBJFILES (so->objfile)
     {
-      if (strcmp (so->objfile->name, so->so_name) == 0)
+      /* Found an already loaded shared library.  */
+      if (strcmp (so->objfile->name, so->so_name) == 0
+	  && !so->main)
+	return 1;
+      /* Found an already loaded main executable.  This could happen in
+	 two circumstances.
+	 First case: the main file has already been read in
+	 as the first thing that gdb does at startup, and the file
+	 hasn't been relocated properly yet. Therefor we need to read
+	 it in with the proper section info.
+	 Second case: it has been read in with the correct relocation,
+	 and therefore we need to skip it.  */
+      if (strcmp (so->objfile->name, so->so_name) == 0
+	  && so->main
+	  && so->main_relocated)
 	return 1;
     }
 
   sap = build_section_addr_info_from_section_table (so->sections,
                                                     so->sections_end);
 
-  so->objfile = symbol_file_add_from_bfd (so->abfd, so->from_tty,
-					  sap, 0, OBJF_SHARED | OBJF_KEEPBFD);
+  if (so->main)
+    {
+      if (debug_solib)
+        fprintf_unfiltered (gdb_stdlog,
+			    "symbol_add_stub: adding symbols for main\n");
+      so->objfile = symbol_file_add_from_bfd (so->abfd, /*so->from_tty*/ 0,
+					      sap, 1, OBJF_KEEPBFD);
+      so->main_relocated = 1;
+    }
+  else
+    so->objfile = symbol_file_add_from_bfd (so->abfd, so->from_tty,
+					    sap, 0, OBJF_SHARED | OBJF_KEEPBFD);
+
   free_section_addr_info (sap);
 
   return (1);
@@ -600,6 +642,10 @@ update_solib_list (int from_tty, struct 
 	    }
 	  else
 	    {
+	      if (debug_solib)
+		fprintf_unfiltered (gdb_stdlog,
+				    "update_solib_list: compare gdb:%s and inferior:%s\n",
+				    gdb->so_original_name, i->so_original_name);
 	      if (! strcmp (gdb->so_original_name, i->so_original_name))
 		break;	      
 	    }
@@ -654,28 +700,7 @@ update_solib_list (int from_tty, struct 
       /* Fill in the rest of each of the `struct so_list' nodes.  */
       for (i = inferior; i; i = i->next)
 	{
-	  i->from_tty = from_tty;
-
-	  /* Fill in the rest of the `struct so_list' node.  */
-	  catch_errors (solib_map_sections, i,
-			"Error while mapping shared library sections:\n",
-			RETURN_MASK_ALL);
-
-	  /* If requested, add the shared object's sections to the TARGET's
-	     section table.  Do this immediately after mapping the object so
-	     that later nodes in the list can query this object, as is needed
-	     in solib-osf.c.  */
-	  if (target)
-	    {
-	      int count = (i->sections_end - i->sections);
-	      if (count > 0)
-		{
-		  int space = target_resize_to_sections (target, count);
-		  memcpy (target->to_sections + space,
-			  i->sections,
-			  count * sizeof (i->sections[0]));
-		}
-	    }
+   	  add_to_target_sections (from_tty, target, i);
 
 	  /* Notify any observer that the shared object has been
              loaded now that we've added it to GDB's tables.  */
@@ -771,6 +796,41 @@ solib_add (char *pattern, int from_tty, 
   }
 }
 
+void
+add_to_target_sections (int from_tty, struct target_ops *target, struct so_list *solib)
+{
+  /* If this is set, then the sections have been already added to the
+     target list.  */
+  if (solib->main)
+    return;
+
+  solib->from_tty = from_tty;
+
+  /* Fill in the rest of the `struct so_list' node.  */
+  catch_errors (solib_map_sections, solib,
+		"Error while mapping shared library sections:\n",
+		RETURN_MASK_ALL);
+
+  /* If requested, add the shared object's sections to the TARGET's
+     section table.  Do this immediately after mapping the object so
+     that later nodes in the list can query this object, as is needed
+     in solib-osf.c.  */
+  if (target)
+    {
+      int count = (solib->sections_end - solib->sections);
+      if (count > 0)
+	{
+	  int space = target_resize_to_sections (target, count);
+          if (debug_solib)
+             fprintf_unfiltered (gdb_stdlog,
+                                 "add_to_target_sections: add %s to to_sections\n",
+                                 solib->so_original_name);
+	  memcpy (target->to_sections + space,
+		  solib->sections,
+		  count * sizeof (solib->sections[0]));
+	}
+    }
+}
 
 /*
 
@@ -1089,4 +1149,12 @@ This takes precedence over the environme
 				     reload_shared_libraries,
 				     show_solib_search_path,
 				     &setlist, &showlist);
+
+  add_setshow_boolean_cmd ("solib", no_class, &debug_solib,
+			   _("\
+Set debugging of GNU/Linux shlib module.\n"), _("\
+Show debugging status of GNU/Linux shlib module.\n"), _("\
+Enables printf debugging output of GNU/Linux shlib module.\n"),
+			   NULL, NULL,
+			   &setdebuglist, &showdebuglist);
 }
Index: gdb-6.8.50.20090302/gdb/solist.h
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/solist.h	2009-02-04 09:42:11.000000000 +0100
+++ gdb-6.8.50.20090302/gdb/solist.h	2009-03-07 00:30:12.000000000 +0100
@@ -61,6 +61,8 @@ struct so_list
     bfd *abfd;
     char symbols_loaded;	/* flag: symbols read in yet? */
     char from_tty;		/* flag: print msgs? */
+    char main;                  /* flag: is this the main executable? */
+    char main_relocated;        /* flag: has it been relocated yet? */
     struct objfile *objfile;	/* objfile for loaded lib */
     struct section_table *sections;
     struct section_table *sections_end;
@@ -149,4 +151,10 @@ struct symbol *solib_global_lookup (cons
 				    const char *linkage_name,
 				    const domain_enum domain);
 
+/* Add the list of sections in so_list to the target to_sections.  */
+extern void add_to_target_sections (int, struct target_ops *, struct so_list *);
+
+/* Controls the printing of debugging output.  */
+extern int debug_solib;
+
 #endif
Index: gdb-6.8.50.20090302/gdb/symfile-mem.c
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/symfile-mem.c	2009-03-07 00:30:08.000000000 +0100
+++ gdb-6.8.50.20090302/gdb/symfile-mem.c	2009-03-07 00:30:12.000000000 +0100
@@ -116,7 +116,7 @@ symbol_file_add_from_memory (struct bfd 
       }
 
   objf = symbol_file_add_from_bfd (nbfd, from_tty,
-                                   sai, 0, OBJF_SHARED);
+                                   sai, 2, OBJF_SHARED);
 
   /* This might change our ideas about frames already looked at.  */
   reinit_frame_cache ();
Index: gdb-6.8.50.20090302/gdb/symfile.c
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/symfile.c	2009-03-07 00:30:09.000000000 +0100
+++ gdb-6.8.50.20090302/gdb/symfile.c	2009-03-07 00:31:24.000000000 +0100
@@ -47,6 +47,7 @@
 #include "readline/readline.h"
 #include "gdb_assert.h"
 #include "block.h"
+#include "varobj.h"
 #include "observer.h"
 #include "exec.h"
 #include "parser-defs.h"
@@ -787,7 +788,7 @@ syms_from_objfile (struct objfile *objfi
 
   /* Now either addrs or offsets is non-zero.  */
 
-  if (mainline)
+  if (mainline == 1)
     {
       /* We will modify the main symbol table, make sure that all its users
          will be cleaned up if an error occurs during symbol reading.  */
@@ -815,7 +816,7 @@ syms_from_objfile (struct objfile *objfi
 
      We no longer warn if the lowest section is not a text segment (as
      happens for the PA64 port.  */
-  if (!mainline && addrs && addrs->other[0].name)
+  if (/*!mainline &&*/ addrs && addrs->other[0].name)
     {
       asection *lower_sect;
       asection *sect;
@@ -917,17 +918,21 @@ new_symfile_objfile (struct objfile *obj
   /* If this is the main symbol file we have to clean up all users of the
      old main symbol file. Otherwise it is sufficient to fixup all the
      breakpoints that may have been redefined by this symbol file.  */
-  if (mainline)
+  if (mainline == 1)
     {
       /* OK, make it the "real" symbol file.  */
       symfile_objfile = objfile;
 
       clear_symtab_users ();
     }
-  else
+  else if (mainline == 0)
     {
       breakpoint_re_set ();
     }
+  else
+    {
+      /* Don't reset breakpoints or it will screw up PIE.  */
+    }
 
   /* We're done reading the symbol file; finish off complaints.  */
   clear_complaints (&symfile_complaints, 0, verbo);
@@ -980,7 +985,7 @@ symbol_file_add_with_addrs_or_offsets (b
   /* Give user a chance to burp if we'd be
      interactively wiping out any existing symbols.  */
 
-  if (mainline
+  if (mainline == 1
       && from_tty
       && (have_full_symbols () || have_partial_symbols ())
       && !query (_("Load new symbol table from \"%s\"? "), name))
@@ -1175,6 +1180,10 @@ symbol_file_clear (int from_tty)
 		    symfile_objfile->name)
 	  : !query (_("Discard symbol table? "))))
     error (_("Not confirmed."));
+#ifdef CLEAR_SOLIB
+      CLEAR_SOLIB ();
+#endif
+
     free_all_objfiles ();
 
     /* solib descriptors may have handles to objfiles.  Since their
@@ -3275,6 +3284,8 @@ reread_symbols (void)
 	      /* Discard cleanups as symbol reading was successful.  */
 	      discard_cleanups (old_cleanups);
 
+	      init_entry_point_info (objfile);
+
 	      /* If the mtime has changed between the time we set new_modtime
 	         and now, we *want* this to be out of date, so don't call stat
 	         again now.  */
Index: gdb-6.8.50.20090302/gdb/target.h
===================================================================
--- gdb-6.8.50.20090302.orig/gdb/target.h	2009-03-07 00:30:09.000000000 +0100
+++ gdb-6.8.50.20090302/gdb/target.h	2009-03-07 00:30:12.000000000 +0100
@@ -542,7 +542,7 @@ struct target_ops
        Return -1 if there is insufficient buffer for a whole entry.
        Return 1 if an entry was read into *TYPEP and *VALP.  */
     int (*to_auxv_parse) (struct target_ops *ops, gdb_byte **readptr,
-                         gdb_byte *endptr, CORE_ADDR *typep, CORE_ADDR *valp);
+                         gdb_byte *endptr, ULONGEST *typep, CORE_ADDR *valp);
 
     /* Search SEARCH_SPACE_LEN bytes beginning at START_ADDR for the
        sequence of bytes in PATTERN with length PATTERN_LEN.
