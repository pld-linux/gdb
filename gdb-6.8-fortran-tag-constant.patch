Index: gdb-7.1.90.20100711/gdb/dwarf2read.c
===================================================================
--- gdb-7.1.90.20100711.orig/gdb/dwarf2read.c	2010-07-12 23:07:35.000000000 +0200
+++ gdb-7.1.90.20100711/gdb/dwarf2read.c	2010-07-13 00:13:02.000000000 +0200
@@ -2251,6 +2251,7 @@ scan_partial_symbols (struct partial_die
 	      add_partial_subprogram (pdi, lowpc, highpc, need_pc, cu);
 	      break;
 	    case DW_TAG_variable:
+	    case DW_TAG_constant:
 	    case DW_TAG_typedef:
 	    case DW_TAG_union_type:
 	      if (!pdi->is_declaration)
@@ -2452,6 +2453,7 @@ add_partial_symbol (struct partial_die_i
 	}
       break;
     case DW_TAG_variable:
+    case DW_TAG_constant:
       if (pdi->is_external)
 	{
 	  /* Global Variable.
@@ -3289,6 +3291,7 @@ die_needs_namespace (struct die_info *di
       return 1;
 
     case DW_TAG_variable:
+    case DW_TAG_constant:
       /* We only need to prefix "globally" visible variables.  These include
 	 any variable marked with DW_AT_external or any variable that
 	 lives in a namespace.  [Variables in anonymous namespaces
@@ -4638,7 +4641,8 @@ dwarf2_add_field (struct field_info *fip
 	  fip->non_public_fields = 1;
 	}
     }
-  else if (die->tag == DW_TAG_member || die->tag == DW_TAG_variable)
+  else if (die->tag == DW_TAG_member || die->tag == DW_TAG_variable
+	   || die->tag == DW_TAG_constant)
     {
       /* C++ static member.  */
 
@@ -5250,7 +5254,8 @@ read_structure_type (struct die_info *di
       while (child_die && child_die->tag)
 	{
 	  if (child_die->tag == DW_TAG_member
-	      || child_die->tag == DW_TAG_variable)
+	      || child_die->tag == DW_TAG_variable
+	      || child_die->tag == DW_TAG_constant)
 	    {
 	      /* NOTE: carlton/2002-11-05: A C++ static data member
 		 should be a DW_TAG_member that is a declaration, but
@@ -5396,6 +5401,7 @@ process_structure_scope (struct die_info
     {
       if (child_die->tag == DW_TAG_member
 	  || child_die->tag == DW_TAG_variable
+	  || child_die->tag == DW_TAG_constant
 	  || child_die->tag == DW_TAG_inheritance)
 	{
 	  /* Do nothing.  */
@@ -7109,6 +7115,7 @@ load_partial_dies (bfd *abfd, gdb_byte *
 	  && abbrev->tag != DW_TAG_subprogram
 	  && abbrev->tag != DW_TAG_lexical_block
 	  && abbrev->tag != DW_TAG_variable
+	  && abbrev->tag != DW_TAG_constant
 	  && abbrev->tag != DW_TAG_namespace
 	  && abbrev->tag != DW_TAG_module
 	  && abbrev->tag != DW_TAG_member)
@@ -7217,6 +7224,7 @@ load_partial_dies (bfd *abfd, gdb_byte *
       if (load_all
 	  || abbrev->tag == DW_TAG_subprogram
 	  || abbrev->tag == DW_TAG_variable
+	  || abbrev->tag == DW_TAG_constant
 	  || abbrev->tag == DW_TAG_namespace
 	  || part_die->is_declaration)
 	{
@@ -9059,6 +9067,11 @@ new_symbol (struct die_info *die, struct
 	  /* Do not add the symbol to any lists.  It will be found via
 	     BLOCK_FUNCTION from the blockvector.  */
 	  break;
+	case DW_TAG_constant:
+	  SYMBOL_TYPE (sym) = make_cv_type (1,
+					    TYPE_VOLATILE (SYMBOL_TYPE (sym)),
+					    SYMBOL_TYPE (sym), NULL);
+	  /* PASSTHRU */
 	case DW_TAG_variable:
 	case DW_TAG_member:
 	  /* Compilation with minimal debug info may result in variables
