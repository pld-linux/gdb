From gdb-patches-return-33534-listarch-gdb-patches=sources dot redhat dot com at sources dot redhat dot com Wed Jun 02 10:03:07 2004
Return-Path: <gdb-patches-return-33534-listarch-gdb-patches=sources dot redhat dot com at sources dot redhat dot com>
Delivered-To: listarch-gdb-patches at sources dot redhat dot com
Received: (qmail 5503 invoked by alias); 2 Jun 2004 10:03:05 -0000
Mailing-List: contact gdb-patches-help at sources dot redhat dot com; run by ezmlm
Precedence: bulk
List-Subscribe: <mailto:gdb-patches-subscribe at sources dot redhat dot com>
List-Archive: <http://sources.redhat.com/ml/gdb-patches/>
List-Post: <mailto:gdb-patches at sources dot redhat dot com>
List-Help: <mailto:gdb-patches-help at sources dot redhat dot com>, <http://sources dot redhat dot com/ml/#faqs>
Sender: gdb-patches-owner at sources dot redhat dot com
Delivered-To: mailing list gdb-patches at sources dot redhat dot com
Received: (qmail 5443 invoked from network); 2 Jun 2004 10:02:47 -0000
Received: from unknown (HELO nile.gnat.com) (205.232.38.5)
  by sourceware dot org with SMTP; 2 Jun 2004 10:02:47 -0000
Received: from localhost (localhost [127.0.0.1])
	by nile dot gnat dot com (Postfix) with ESMTP id 76E9FF282A
	for <gdb-patches at sources dot redhat dot com>; Wed,  2 Jun 2004 06:02:46 -0400 (EDT)
Received: from nile.gnat.com ([127.0.0.1])
 by localhost (nile dot gnat dot com [127 dot 0 dot 0 dot 1]) (amavisd-new, port 10024) with LMTP
 id 04925-01-3 for <gdb-patches at sources dot redhat dot com>;
 Wed,  2 Jun 2004 06:02:46 -0400 (EDT)
Received: by nile.gnat.com (Postfix, from userid 1345)
	id BFFC7F282B; Wed,  2 Jun 2004 06:02:45 -0400 (EDT)
From: Paul Hilfinger <hilfingr at gnat dot com>
To: gdb-patches at sources dot redhat dot com
Subject: [PATCH]: Updates to Ada sources, part 1 (longish)
Message-Id: <20040602100245.BFFC7F282B@nile.gnat.com>
Date: Wed,  2 Jun 2004 06:02:45 -0400 (EDT)
X-Virus-Scanned: by amavisd-new at nile.gnat.com


I have checked in the following patch, which synchronizes the public 
sources with our current development version (since these sources are not
at the moment compiled, it is harmless to do so).  Since the patch is
large, I have broken it up.  This is part 1.

Paul Hilfinger


Changelog:

2004-06-02  Paul N. Hilfinger  <hilfinger@gnat.com>

	* ada-exp.y: Synchronize with current ACT sources.
	* ada-lang.c: Ditto.
	* ada-lang.h: Ditto.
	* ada-lex.l: Ditto.
	* ada-tasks.c: Ditto.
	* ada-typeprint.c: Ditto.
	* ada-valprint.c: Ditto.
	

Index: gdb/ada-exp.y
===================================================================
RCS file: /cvs/src/src/gdb/ada-exp.y,v
retrieving revision 1.8
diff -u -p -r1.8 ada-exp.y
--- gdb/ada-exp.y	23 Nov 2003 20:41:16 -0000	1.8
+++ gdb/ada-exp.y	2 Jun 2004 09:52:54 -0000
@@ -1,6 +1,6 @@
 /* YACC parser for Ada expressions, for GDB.
-   Copyright (C) 1986, 1989, 1990, 1991, 1993, 1994, 1997, 2000, 2003
-   Free Software Foundation, Inc.
+   Copyright (C) 1986, 1989, 1990, 1991, 1993, 1994, 1997, 2000, 2003, 
+   2004 Free Software Foundation, Inc.
 
 This file is part of GDB.
 
@@ -34,7 +34,7 @@ Foundation, Inc., 675 Mass Ave, Cambridg
    with include files (<malloc.h> and <stdlib.h> for example) just became
    too messy, particularly when such includes can be inserted at random
    times by the parser generator.  */
-   
+
 %{
 
 #include "defs.h"
@@ -56,9 +56,9 @@ Foundation, Inc., 675 Mass Ave, Cambridg
    yacc generated parsers in gdb.  These are only the variables
    produced by yacc.  If other parser generators (bison, byacc, etc) produce
    additional global names that conflict at link time, then those parser
-   generators need to be fixed instead of adding those names to this list. */
+   generators need to be fixed instead of adding those names to this list.  */
 
-/* NOTE: This is clumsy, especially since BISON and FLEX provide --prefix  
+/* NOTE: This is clumsy, especially since BISON and FLEX provide --prefix
    options.  I presume we are maintaining it to accommodate systems
    without BISON?  (PNH) */
 
@@ -69,13 +69,13 @@ Foundation, Inc., 675 Mass Ave, Cambridg
 #define	yylval	ada_lval
 #define	yychar	ada_char
 #define	yydebug	ada_debug
-#define	yypact	ada_pact	
-#define	yyr1	ada_r1			
-#define	yyr2	ada_r2			
-#define	yydef	ada_def		
-#define	yychk	ada_chk		
-#define	yypgo	ada_pgo		
-#define	yyact	ada_act		
+#define	yypact	ada_pact
+#define	yyr1	ada_r1
+#define	yyr2	ada_r2
+#define	yydef	ada_def
+#define	yychk	ada_chk
+#define	yypgo	ada_pgo
+#define	yyact	ada_act
 #define	yyexca	ada_exca
 #define yyerrflag ada_errflag
 #define yynerrs	ada_nerrs
@@ -101,15 +101,15 @@ Foundation, Inc., 675 Mass Ave, Cambridg
 #define YYFPRINTF parser_fprintf
 
 struct name_info {
-  struct symbol* sym;
-  struct minimal_symbol* msym;
-  struct block* block;
+  struct symbol *sym;
+  struct minimal_symbol *msym;
+  struct block *block;
   struct stoken stoken;
 };
 
 /* If expression is in the context of TYPE'(...), then TYPE, else
- * NULL. */
-static struct type* type_qualifier;
+ * NULL.  */
+static struct type *type_qualifier;
 
 int yyparse (void);
 
@@ -119,19 +119,15 @@ void yyerror (char *);
 
 static struct stoken string_to_operator (struct stoken);
 
-static void write_attribute_call0 (enum ada_attribute);
-
-static void write_attribute_call1 (enum ada_attribute, LONGEST);
-
-static void write_attribute_calln (enum ada_attribute, int);
+static void write_int (LONGEST, struct type *);
 
-static void write_object_renaming (struct block*, struct symbol*);
+static void write_object_renaming (struct block *, struct symbol *, int);
 
-static void write_var_from_name (struct block*, struct name_info);
+static void write_var_from_name (struct block *, struct name_info);
 
 static LONGEST
-convert_char_literal (struct type*, LONGEST);
-%} 
+convert_char_literal (struct type *, LONGEST);
+%}
 
 %union
   {
@@ -169,9 +165,9 @@ convert_char_literal (struct type*, LONG
    Contexts where this distinction is not important can use the
    nonterminal "name", which matches either NAME or TYPENAME.  */
 
-%token <sval> STRING 
+%token <sval> STRING
 %token <ssym> NAME DOT_ID OBJECT_RENAMING
-%type <bval> block 
+%type <bval> block
 %type <lval> arglist tick_arglist
 
 %type <tval> save_qualifier
@@ -180,9 +176,7 @@ convert_char_literal (struct type*, LONG
 
 /* Special type cases, put in to allow the parser to distinguish different
    legal basetypes.  */
-%token <lval> LAST REGNAME
-
-%token <ivar> INTERNAL_VARIABLE
+%token <sval> SPECIAL_VARIABLE
 
 %nonassoc ASSIGN
 %left _AND_ OR XOR THEN ELSE
@@ -192,9 +186,9 @@ convert_char_literal (struct type*, LONG
 %left UNARY
 %left '*' '/' MOD REM
 %right STARSTAR ABS NOT
- /* The following are right-associative only so that reductions at this 
-    precedence have lower precedence than '.' and '('. The syntax still 
-    forces a.b.c, e.g., to be LEFT-associated. */
+ /* The following are right-associative only so that reductions at this
+    precedence have lower precedence than '.' and '('.  The syntax still
+    forces a.b.c, e.g., to be LEFT-associated.  */
 %right TICK_ACCESS TICK_ADDRESS TICK_FIRST TICK_LAST TICK_LENGTH
 %right TICK_MAX TICK_MIN TICK_MODULUS
 %right TICK_POS TICK_RANGE TICK_SIZE TICK_TAG TICK_VAL
@@ -225,7 +219,7 @@ simple_exp :	simple_exp DOT_ALL
 simple_exp :	simple_exp DOT_ID
 			{ write_exp_elt_opcode (STRUCTOP_STRUCT);
 			  write_exp_string ($2.stoken);
-			  write_exp_elt_opcode (STRUCTOP_STRUCT); 
+			  write_exp_elt_opcode (STRUCTOP_STRUCT);
 			  }
 	;
 
@@ -241,17 +235,15 @@ simple_exp :	type '(' exp ')'
 			{
 			  write_exp_elt_opcode (UNOP_CAST);
 			  write_exp_elt_type ($1);
-			  write_exp_elt_opcode (UNOP_CAST); 
+			  write_exp_elt_opcode (UNOP_CAST);
 			}
 	;
 
 simple_exp :	type '\'' save_qualifier { type_qualifier = $1; } '(' exp ')'
 			{
-			  /*			  write_exp_elt_opcode (UNOP_QUAL); */
-			  /* FIXME: UNOP_QUAL should be defined in expression.h */
+			  write_exp_elt_opcode (UNOP_QUAL);
 			  write_exp_elt_type ($1);
-			  /* write_exp_elt_opcode (UNOP_QUAL); */
-			  /* FIXME: UNOP_QUAL should be defined in expression.h */
+			  write_exp_elt_opcode (UNOP_QUAL);
 			  type_qualifier = $3;
 			}
 	;
@@ -267,34 +259,16 @@ simple_exp :
 simple_exp :	'(' exp1 ')'	{ }
 	;
 
-simple_exp :	variable	
+simple_exp :	variable
 	;
 
-simple_exp:	REGNAME /* GDB extension */
-			{ write_exp_elt_opcode (OP_REGISTER);
-			  write_exp_elt_longcst ((LONGEST) $1);
-			  write_exp_elt_opcode (OP_REGISTER); 
-			}
+simple_exp:	SPECIAL_VARIABLE /* Various GDB extensions */
+			{ write_dollar_variable ($1); }
 	;
 
-simple_exp:	INTERNAL_VARIABLE /* GDB extension */
-			{ write_exp_elt_opcode (OP_INTERNALVAR);
-			  write_exp_elt_intern ($1);
-			  write_exp_elt_opcode (OP_INTERNALVAR); 
-			}
-	;
-
-
 exp	: 	simple_exp
 	;
 
-simple_exp:	LAST
-			{ write_exp_elt_opcode (OP_LAST);
-			  write_exp_elt_longcst ((LONGEST) $1);
-			  write_exp_elt_opcode (OP_LAST); 
-			 }
-	;
-
 exp	: 	exp ASSIGN exp   /* Extension for convenience */
 			{ write_exp_elt_opcode (BINOP_ASSIGN); }
 	;
@@ -332,7 +306,7 @@ exp	:	'{' type '}' exp  %prec '.'
 		/* GDB extension */
 			{ write_exp_elt_opcode (UNOP_MEMVAL);
 			  write_exp_elt_type ($2);
-			  write_exp_elt_opcode (UNOP_MEMVAL); 
+			  write_exp_elt_opcode (UNOP_MEMVAL);
 			}
 	;
 
@@ -387,42 +361,32 @@ exp	:	exp LEQ exp
 	;
 
 exp	:	exp IN exp DOTDOT exp
-                        { /*write_exp_elt_opcode (TERNOP_MBR); */ }
-                          /* FIXME: TERNOP_MBR should be defined in
-			     expression.h */
+			{ write_exp_elt_opcode (TERNOP_IN_RANGE); }
         |       exp IN exp TICK_RANGE tick_arglist
-                        { /*write_exp_elt_opcode (BINOP_MBR); */
-			  /* FIXME: BINOP_MBR should be defined in expression.h */
+			{ write_exp_elt_opcode (BINOP_IN_BOUNDS);
 			  write_exp_elt_longcst ((LONGEST) $5);
-			  /*write_exp_elt_opcode (BINOP_MBR); */
+			  write_exp_elt_opcode (BINOP_IN_BOUNDS);
 			}
  	|	exp IN TYPENAME		%prec TICK_ACCESS
-                        { /*write_exp_elt_opcode (UNOP_MBR); */
-			  /* FIXME: UNOP_QUAL should be defined in expression.h */			  
+			{ write_exp_elt_opcode (UNOP_IN_RANGE);
 		          write_exp_elt_type ($3);
-			  /*		          write_exp_elt_opcode (UNOP_MBR); */
-			  /* FIXME: UNOP_MBR should be defined in expression.h */			  
+		          write_exp_elt_opcode (UNOP_IN_RANGE);
 			}
 	|	exp NOT IN exp DOTDOT exp
-                        { /*write_exp_elt_opcode (TERNOP_MBR); */
-			  /* FIXME: TERNOP_MBR should be defined in expression.h */			  			  
-		          write_exp_elt_opcode (UNOP_LOGICAL_NOT); 
+			{ write_exp_elt_opcode (TERNOP_IN_RANGE);
+		          write_exp_elt_opcode (UNOP_LOGICAL_NOT);
 			}
         |       exp NOT IN exp TICK_RANGE tick_arglist
-                        { /* write_exp_elt_opcode (BINOP_MBR); */
-			  /* FIXME: BINOP_MBR should be defined in expression.h */
+			{ write_exp_elt_opcode (BINOP_IN_BOUNDS);
 			  write_exp_elt_longcst ((LONGEST) $6);
-			  /*write_exp_elt_opcode (BINOP_MBR);*/
-			  /* FIXME: BINOP_MBR should be defined in expression.h */			  
-		          write_exp_elt_opcode (UNOP_LOGICAL_NOT); 
+			  write_exp_elt_opcode (BINOP_IN_BOUNDS);
+		          write_exp_elt_opcode (UNOP_LOGICAL_NOT);
 			}
  	|	exp NOT IN TYPENAME	%prec TICK_ACCESS
-                        { /*write_exp_elt_opcode (UNOP_MBR);*/
-			  /* FIXME: UNOP_MBR should be defined in expression.h */			  
+			{ write_exp_elt_opcode (UNOP_IN_RANGE);
 		          write_exp_elt_type ($4);
-			  /*		          write_exp_elt_opcode (UNOP_MBR);*/
-			  /* FIXME: UNOP_MBR should be defined in expression.h */			  			  
-		          write_exp_elt_opcode (UNOP_LOGICAL_NOT); 
+		          write_exp_elt_opcode (UNOP_IN_RANGE);
+		          write_exp_elt_opcode (UNOP_LOGICAL_NOT);
 			}
 	;
 
@@ -438,7 +402,7 @@ exp	:	exp '>' exp
 			{ write_exp_elt_opcode (BINOP_GTR); }
 	;
 
-exp     :	exp _AND_ exp  /* Fix for Ada elementwise AND. */
+exp     :	exp _AND_ exp  /* Fix for Ada elementwise AND.  */
 			{ write_exp_elt_opcode (BINOP_BITWISE_AND); }
         ;
 
@@ -450,7 +414,7 @@ exp     :	exp OR exp     /* Fix for Ada 
 			{ write_exp_elt_opcode (BINOP_BITWISE_IOR); }
         ;
 
-exp     :       exp OR ELSE exp        
+exp     :       exp OR ELSE exp
 			{ write_exp_elt_opcode (BINOP_LOGICAL_OR); }
         ;
 
@@ -467,31 +431,37 @@ simple_exp :	simple_exp TICK_ACCESS
 			  write_exp_elt_opcode (UNOP_CAST);
 			}
 	|	simple_exp TICK_FIRST tick_arglist
-			{ write_attribute_call1 (ATR_FIRST, $3); }
+			{ write_int ($3, builtin_type_int);
+			  write_exp_elt_opcode (OP_ATR_FIRST); }
 	|	simple_exp TICK_LAST tick_arglist
-			{ write_attribute_call1 (ATR_LAST, $3); }
+			{ write_int ($3, builtin_type_int);
+			  write_exp_elt_opcode (OP_ATR_LAST); }
 	| 	simple_exp TICK_LENGTH tick_arglist
-			{ write_attribute_call1 (ATR_LENGTH, $3); }
-        |       simple_exp TICK_SIZE 
-			{ write_attribute_call0 (ATR_SIZE); }
+			{ write_int ($3, builtin_type_int);
+			  write_exp_elt_opcode (OP_ATR_LENGTH); }
+        |       simple_exp TICK_SIZE
+			{ write_exp_elt_opcode (OP_ATR_SIZE); }
 	|	simple_exp TICK_TAG
-			{ write_attribute_call0 (ATR_TAG); }
+			{ write_exp_elt_opcode (OP_ATR_TAG); }
         |       opt_type_prefix TICK_MIN '(' exp ',' exp ')'
-			{ write_attribute_calln (ATR_MIN, 2); }
+			{ write_exp_elt_opcode (OP_ATR_MIN); }
         |       opt_type_prefix TICK_MAX '(' exp ',' exp ')'
-			{ write_attribute_calln (ATR_MAX, 2); }
+			{ write_exp_elt_opcode (OP_ATR_MAX); }
 	| 	opt_type_prefix TICK_POS '(' exp ')'
-			{ write_attribute_calln (ATR_POS, 1); }
+			{ write_exp_elt_opcode (OP_ATR_POS); }
 	|	type_prefix TICK_FIRST tick_arglist
-			{ write_attribute_call1 (ATR_FIRST, $3); }
+			{ write_int ($3, builtin_type_int);
+			  write_exp_elt_opcode (OP_ATR_FIRST); }
 	|	type_prefix TICK_LAST tick_arglist
-			{ write_attribute_call1 (ATR_LAST, $3); }
+			{ write_int ($3, builtin_type_int);
+			  write_exp_elt_opcode (OP_ATR_LAST); }
 	| 	type_prefix TICK_LENGTH tick_arglist
-			{ write_attribute_call1 (ATR_LENGTH, $3); }
+			{ write_int ($3, builtin_type_int);
+			  write_exp_elt_opcode (OP_ATR_LENGTH); }
 	|	type_prefix TICK_VAL '(' exp ')'
-			{ write_attribute_calln (ATR_VAL, 1); }
-	|	type_prefix TICK_MODULUS 
-			{ write_attribute_call0 (ATR_MODULUS); }
+			{ write_exp_elt_opcode (OP_ATR_VAL); }
+	|	type_prefix TICK_MODULUS
+			{ write_exp_elt_opcode (OP_ATR_MODULUS); }
 	;
 
 tick_arglist :			%prec '('
@@ -509,74 +479,42 @@ type_prefix :
 
 opt_type_prefix :
 		type_prefix
-	| 	/* EMPTY */     
+	| 	/* EMPTY */
 			{ write_exp_elt_opcode (OP_TYPE);
 			  write_exp_elt_type (builtin_type_void);
 			  write_exp_elt_opcode (OP_TYPE); }
 	;
-		
+
 
 exp	:	INT
-			{ write_exp_elt_opcode (OP_LONG);
-			  write_exp_elt_type ($1.type);
-			  write_exp_elt_longcst ((LONGEST)($1.val));
-			  write_exp_elt_opcode (OP_LONG); 
-			}
+			{ write_int ((LONGEST) $1.val, $1.type); }
 	;
 
 exp	:	CHARLIT
-			{ write_exp_elt_opcode (OP_LONG);
-			  if (type_qualifier == NULL) 
-			    write_exp_elt_type ($1.type);
-			  else
-			    write_exp_elt_type (type_qualifier);
-			  write_exp_elt_longcst 
-			    (convert_char_literal (type_qualifier, $1.val));
-			  write_exp_elt_opcode (OP_LONG); 
-			}
+                  { write_int (convert_char_literal (type_qualifier, $1.val),
+			       (type_qualifier == NULL) 
+			       ? $1.type : type_qualifier);
+		  }
 	;
-			      
+
 exp	:	FLOAT
 			{ write_exp_elt_opcode (OP_DOUBLE);
 			  write_exp_elt_type ($1.type);
 			  write_exp_elt_dblcst ($1.dval);
-			  write_exp_elt_opcode (OP_DOUBLE); 
+			  write_exp_elt_opcode (OP_DOUBLE);
 			}
 	;
 
 exp	:	NULL_PTR
-			{ write_exp_elt_opcode (OP_LONG);
-			  write_exp_elt_type (builtin_type_int);
-			  write_exp_elt_longcst ((LONGEST)(0));
-			  write_exp_elt_opcode (OP_LONG); 
-			 }
+			{ write_int (0, builtin_type_int); }
 	;
 
 exp	:	STRING
-			{ /* Ada strings are converted into array constants 
-			     a lower bound of 1.  Thus, the array upper bound 
-			     is the string length. */
-			  char *sp = $1.ptr; int count;
-			  if ($1.length == 0) 
-			    { /* One dummy character for the type */
-			      write_exp_elt_opcode (OP_LONG);
-			      write_exp_elt_type (builtin_type_ada_char);
-			      write_exp_elt_longcst ((LONGEST)(0));
-			      write_exp_elt_opcode (OP_LONG);
-			    }
-			  for (count = $1.length; count > 0; count -= 1)
-			    {
-			      write_exp_elt_opcode (OP_LONG);
-			      write_exp_elt_type (builtin_type_ada_char);
-			      write_exp_elt_longcst ((LONGEST)(*sp));
-			      sp += 1;
-			      write_exp_elt_opcode (OP_LONG);
-			    }
-			  write_exp_elt_opcode (OP_ARRAY);
-			  write_exp_elt_longcst ((LONGEST) 1);
-			  write_exp_elt_longcst ((LONGEST) ($1.length));
-			  write_exp_elt_opcode (OP_ARRAY); 
-			 }
+			{ 
+			  write_exp_elt_opcode (OP_STRING);
+			  write_exp_string ($1);
+			  write_exp_elt_opcode (OP_STRING);
+			}
 	;
 
 exp	: 	NEW TYPENAME
@@ -586,9 +524,12 @@ exp	: 	NEW TYPENAME
 variable:	NAME   		{ write_var_from_name (NULL, $1); }
 	|	block NAME  	/* GDB extension */
                                 { write_var_from_name ($1, $2); }
-	|	OBJECT_RENAMING { write_object_renaming (NULL, $1.sym); }
-	|	block OBJECT_RENAMING 
-				{ write_object_renaming ($1, $2.sym); }
+	|	OBJECT_RENAMING 
+		    { write_object_renaming (NULL, $1.sym, 
+				             MAX_RENAMING_CHAIN_LENGTH); }
+	|	block OBJECT_RENAMING
+		    { write_object_renaming ($1, $2.sym, 
+					     MAX_RENAMING_CHAIN_LENGTH); }
 	;
 
 any_name :	NAME 		{ }
@@ -605,14 +546,14 @@ block	:	BLOCKNAME  /* GDB extension */
 
 type	:	TYPENAME	{ $$ = $1; }
 	|	block TYPENAME  { $$ = $2; }
-	| 	TYPENAME TICK_ACCESS 
+	| 	TYPENAME TICK_ACCESS
 				{ $$ = lookup_pointer_type ($1); }
 	|	block TYPENAME TICK_ACCESS
 				{ $$ = lookup_pointer_type ($2); }
         ;
 
 /* Some extensions borrowed from C, for the benefit of those who find they
-   can't get used to Ada notation in GDB. */
+   can't get used to Ada notation in GDB.  */
 
 exp	:	'*' exp		%prec '.'
 			{ write_exp_elt_opcode (UNOP_IND); }
@@ -642,49 +583,51 @@ exp	:	'*' exp		%prec '.'
 #define yytext ada_yytext
 #define yywrap ada_yywrap
 
+static struct obstack temp_parse_space;
+
 /* The following kludge was found necessary to prevent conflicts between */
 /* defs.h and non-standard stdlib.h files.  */
 #define qsort __qsort__dummy
 #include "ada-lex.c"
 
 int
-ada_parse ()
+ada_parse (void)
 {
-  lexer_init (yyin);		/* (Re-)initialize lexer. */
+  lexer_init (yyin);		/* (Re-)initialize lexer.  */
   left_block_context = NULL;
   type_qualifier = NULL;
-  
+  obstack_free (&temp_parse_space, NULL);
+  obstack_init (&temp_parse_space);
+
   return _ada_parse ();
 }
 
 void
-yyerror (msg)
-     char *msg;
+yyerror (char *msg)
 {
   error ("A %s in expression, near `%s'.", (msg ? msg : "error"), lexptr);
 }
 
-/* The operator name corresponding to operator symbol STRING (adds 
+/* The operator name corresponding to operator symbol STRING (adds
    quotes and maps to lower-case).  Destroys the previous contents of
    the array pointed to by STRING.ptr.  Error if STRING does not match
    a valid Ada operator.  Assumes that STRING.ptr points to a
    null-terminated string and that, if STRING is a valid operator
    symbol, the array pointed to by STRING.ptr contains at least
-   STRING.length+3 characters. */ 
+   STRING.length+3 characters.  */
 
 static struct stoken
-string_to_operator (string)
-     struct stoken string;
+string_to_operator (struct stoken string)
 {
   int i;
 
-  for (i = 0; ada_opname_table[i].mangled != NULL; i += 1)
+  for (i = 0; ada_opname_table[i].encoded != NULL; i += 1)
     {
-      if (string.length == strlen (ada_opname_table[i].demangled)-2
-	  && strncasecmp (string.ptr, ada_opname_table[i].demangled+1,
+      if (string.length == strlen (ada_opname_table[i].decoded)-2
+	  && strncasecmp (string.ptr, ada_opname_table[i].decoded+1,
 			  string.length) == 0)
 	{
-	  strncpy (string.ptr, ada_opname_table[i].demangled,
+	  strncpy (string.ptr, ada_opname_table[i].decoded,
 		   string.length+2);
 	  string.length += 2;
 	  return string;
@@ -694,12 +637,11 @@ string_to_operator (string)
 }
 
 /* Emit expression to access an instance of SYM, in block BLOCK (if
- * non-NULL), and with :: qualification ORIG_LEFT_CONTEXT. */
+ * non-NULL), and with :: qualification ORIG_LEFT_CONTEXT.  */
 static void
-write_var_from_sym (orig_left_context, block, sym)
-     struct block* orig_left_context;
-     struct block* block;
-     struct symbol* sym;
+write_var_from_sym (struct block *orig_left_context,
+		    struct block *block,
+		    struct symbol *sym)
 {
   if (orig_left_context == NULL && symbol_read_needs_frame (sym))
     {
@@ -709,121 +651,91 @@ write_var_from_sym (orig_left_context, b
     }
 
   write_exp_elt_opcode (OP_VAR_VALUE);
-  /* We want to use the selected frame, not another more inner frame
-     which happens to be in the same block */
-  write_exp_elt_block (NULL);
+  write_exp_elt_block (block);
   write_exp_elt_sym (sym);
   write_exp_elt_opcode (OP_VAR_VALUE);
 }
 
-/* Emit expression to access an instance of NAME. */
+/* Emit expression to access an instance of NAME in :: context
+ * ORIG_LEFT_CONTEXT.  If no unique symbol for NAME has been found,
+ * output a dummy symbol (good to the next call of ada_parse) for NAME
+ * in the UNDEF_DOMAIN, for later resolution by ada_resolve.  */
 static void
-write_var_from_name (orig_left_context, name)
-     struct block* orig_left_context;
-     struct name_info name;
+write_var_from_name (struct block *orig_left_context,
+		     struct name_info name)
 {
   if (name.msym != NULL)
     {
-      write_exp_msymbol (name.msym, 
+      write_exp_msymbol (name.msym,
 			 lookup_function_type (builtin_type_int),
 			 builtin_type_int);
     }
-  else if (name.sym == NULL) 
+  else if (name.sym == NULL)
     {
-      /* Multiple matches: record name and starting block for later 
-         resolution by ada_resolve. */
-      /*      write_exp_elt_opcode (OP_UNRESOLVED_VALUE); */
-      /* FIXME: OP_UNRESOLVED_VALUE should be defined in expression.h */      
+      /* Multiple matches: record name and starting block for later
+         resolution by ada_resolve.  */
+      char *encoded_name = ada_encode (name.stoken.ptr);
+      struct symbol *sym =
+	obstack_alloc (&temp_parse_space, sizeof (struct symbol));
+      memset (sym, 0, sizeof (struct symbol));
+      SYMBOL_DOMAIN (sym) = UNDEF_DOMAIN;
+      SYMBOL_LINKAGE_NAME (sym)
+	= obsavestring (encoded_name, strlen (encoded_name), &temp_parse_space);
+      SYMBOL_LANGUAGE (sym) = language_ada;
+
+      write_exp_elt_opcode (OP_VAR_VALUE);
       write_exp_elt_block (name.block);
-      /*      write_exp_elt_name (name.stoken.ptr); */
-      /* FIXME: write_exp_elt_name should be defined in defs.h, located in parse.c */      
-      /*      write_exp_elt_opcode (OP_UNRESOLVED_VALUE); */
-      /* FIXME: OP_UNRESOLVED_VALUE should be defined in expression.h */      
+      write_exp_elt_sym (sym);
+      write_exp_elt_opcode (OP_VAR_VALUE);
     }
   else
     write_var_from_sym (orig_left_context, name.block, name.sym);
 }
 
-/* Write a call on parameterless attribute ATR.  */
-
-static void
-write_attribute_call0 (atr)
-     enum ada_attribute atr;
-{
-  /*  write_exp_elt_opcode (OP_ATTRIBUTE); */
-  /* FIXME: OP_ATTRIBUTE should be defined in expression.h */      
-  write_exp_elt_longcst ((LONGEST) 0);
-  write_exp_elt_longcst ((LONGEST) atr);
-  /*  write_exp_elt_opcode (OP_ATTRIBUTE); */
-  /* FIXME: OP_ATTRIBUTE should be defined in expression.h */      
-}
-
-/* Write a call on an attribute ATR with one constant integer
- * parameter. */
+/* Write integer constant ARG of type TYPE.  */
 
 static void
-write_attribute_call1 (atr, arg)
-     enum ada_attribute atr;
-     LONGEST arg;
+write_int (LONGEST arg, struct type *type)
 {
   write_exp_elt_opcode (OP_LONG);
-  write_exp_elt_type (builtin_type_int);
+  write_exp_elt_type (type);
   write_exp_elt_longcst (arg);
   write_exp_elt_opcode (OP_LONG);
-  /*write_exp_elt_opcode (OP_ATTRIBUTE);*/
-  /* FIXME: OP_ATTRIBUTE should be defined in expression.h */
-  write_exp_elt_longcst ((LONGEST) 1);
-  write_exp_elt_longcst ((LONGEST) atr);
-  /*write_exp_elt_opcode (OP_ATTRIBUTE);*/
-  /* FIXME: OP_ATTRIBUTE should be defined in expression.h */        
-}  
-
-/* Write a call on an attribute ATR with N parameters, whose code must have
- * been generated previously. */
-
-static void
-write_attribute_calln (atr, n)
-     enum ada_attribute atr;
-     int n;
-{
-  /*write_exp_elt_opcode (OP_ATTRIBUTE);*/
-  /* FIXME: OP_ATTRIBUTE should be defined in expression.h */      
-  write_exp_elt_longcst ((LONGEST) n);
-  write_exp_elt_longcst ((LONGEST) atr);
-  /*  write_exp_elt_opcode (OP_ATTRIBUTE);*/
-  /* FIXME: OP_ATTRIBUTE should be defined in expression.h */        
-}  
+}
 
-/* Emit expression corresponding to the renamed object designated by 
+/* Emit expression corresponding to the renamed object designated by
  * the type RENAMING, which must be the referent of an object renaming
- * type, in the context of ORIG_LEFT_CONTEXT (?). */
+ * type, in the context of ORIG_LEFT_CONTEXT.  MAX_DEPTH is the maximum
+ * number of cascaded renamings to allow.  */
 static void
-write_object_renaming (orig_left_context, renaming)
-     struct block* orig_left_context;
-     struct symbol* renaming;
+write_object_renaming (struct block *orig_left_context, 
+		       struct symbol *renaming, int max_depth)
 {
-  const char* qualification = DEPRECATED_SYMBOL_NAME (renaming);
-  const char* simple_tail;
-  const char* expr = TYPE_FIELD_NAME (SYMBOL_TYPE (renaming), 0);
-  const char* suffix;
-  char* name;
-  struct symbol* sym;
+  const char *qualification = SYMBOL_LINKAGE_NAME (renaming);
+  const char *simple_tail;
+  const char *expr = TYPE_FIELD_NAME (SYMBOL_TYPE (renaming), 0);
+  const char *suffix;
+  char *name;
+  struct symbol *sym;
   enum { SIMPLE_INDEX, LOWER_BOUND, UPPER_BOUND } slice_state;
 
+  if (max_depth <= 0)
+    error ("Could not find renamed symbol");
+
   /* if orig_left_context is null, then use the currently selected
-     block, otherwise we might fail our symbol lookup below */
+     block; otherwise we might fail our symbol lookup below.  */
   if (orig_left_context == NULL)
     orig_left_context = get_selected_block (NULL);
 
-  for (simple_tail = qualification + strlen (qualification); 
+  for (simple_tail = qualification + strlen (qualification);
        simple_tail != qualification; simple_tail -= 1)
     {
       if (*simple_tail == '.')
 	{
 	  simple_tail += 1;
 	  break;
-	} 
-      else if (DEPRECATED_STREQN (simple_tail, "__", 2))
+	}
+      else if (strncmp (simple_tail, "__", 2) == 0)
 	{
 	  simple_tail += 2;
 	  break;
@@ -834,72 +746,72 @@ write_object_renaming (orig_left_context
   if (suffix == NULL)
     goto BadEncoding;
 
-  name = (char*) malloc (suffix - expr + 1);
-  /*  add_name_string_cleanup (name); */
-  /* FIXME: add_name_string_cleanup should be defined in
-     parser-defs.h, implemented in parse.c */    
+  name = (char *) obstack_alloc (&temp_parse_space, suffix - expr + 1);
   strncpy (name, expr, suffix-expr);
   name[suffix-expr] = '\000';
   sym = lookup_symbol (name, orig_left_context, VAR_DOMAIN, 0, NULL);
-  /*  if (sym == NULL) 
-    error ("Could not find renamed variable: %s", ada_demangle (name));
-  */
-  /* FIXME: ada_demangle should be defined in defs.h, implemented in ada-lang.c */  
-  write_var_from_sym (orig_left_context, block_found, sym);
+  if (sym == NULL)
+    error ("Could not find renamed variable: %s", ada_decode (name));
+  if (ada_is_object_renaming (sym))
+    write_object_renaming (orig_left_context, sym, max_depth-1);
+  else
+    write_var_from_sym (orig_left_context, block_found, sym);
 
   suffix += 5;
   slice_state = SIMPLE_INDEX;
-  while (*suffix == 'X') 
+  while (*suffix == 'X')
     {
       suffix += 1;
 
       switch (*suffix) {
+      case 'A':
+        suffix += 1;
+        write_exp_elt_opcode (UNOP_IND);
+        break;
       case 'L':
 	slice_state = LOWER_BOUND;
       case 'S':
 	suffix += 1;
-	if (isdigit (*suffix)) 
+	if (isdigit (*suffix))
 	  {
-	    char* next;
+	    char *next;
 	    long val = strtol (suffix, &next, 10);
-	    if (next == suffix) 
+	    if (next == suffix)
 	      goto BadEncoding;
 	    suffix = next;
 	    write_exp_elt_opcode (OP_LONG);
 	    write_exp_elt_type (builtin_type_ada_int);
 	    write_exp_elt_longcst ((LONGEST) val);
 	    write_exp_elt_opcode (OP_LONG);
-	  } 
+	  }
 	else
 	  {
-	    const char* end;
-	    char* index_name;
+	    const char *end;
+	    char *index_name;
 	    int index_len;
-	    struct symbol* index_sym;
+	    struct symbol *index_sym;
 
 	    end = strchr (suffix, 'X');
-	    if (end == NULL) 
+	    if (end == NULL)
 	      end = suffix + strlen (suffix);
-	    
+
 	    index_len = simple_tail - qualification + 2 + (suffix - end) + 1;
-	    index_name = (char*) malloc (index_len);
+	    index_name
+	      = (char *) obstack_alloc (&temp_parse_space, index_len);
 	    memset (index_name, '\000', index_len);
-	    /*	    add_name_string_cleanup (index_name);*/
-	    /* FIXME: add_name_string_cleanup should be defined in
-	       parser-defs.h, implemented in parse.c */    	    
 	    strncpy (index_name, qualification, simple_tail - qualification);
 	    index_name[simple_tail - qualification] = '\000';
 	    strncat (index_name, suffix, suffix-end);
 	    suffix = end;
 
-	    index_sym = 
+	    index_sym =
 	      lookup_symbol (index_name, NULL, VAR_DOMAIN, 0, NULL);
 	    if (index_sym == NULL)
 	      error ("Could not find %s", index_name);
 	    write_var_from_sym (NULL, block_found, sym);
 	  }
 	if (slice_state == SIMPLE_INDEX)
-	  { 
+	  {
 	    write_exp_elt_opcode (OP_FUNCALL);
 	    write_exp_elt_longcst ((LONGEST) 1);
 	    write_exp_elt_opcode (OP_FUNCALL);
@@ -916,25 +828,25 @@ write_object_renaming (orig_left_context
       case 'R':
 	{
 	  struct stoken field_name;
-	  const char* end;
+	  const char *end;
 	  suffix += 1;
-	  
+
 	  if (slice_state != SIMPLE_INDEX)
 	    goto BadEncoding;
 	  end = strchr (suffix, 'X');
-	  if (end == NULL) 
+	  if (end == NULL)
 	    end = suffix + strlen (suffix);
 	  field_name.length = end - suffix;
-	  field_name.ptr = (char*) malloc (end - suffix + 1);
+	  field_name.ptr = (char *) malloc (end - suffix + 1);
 	  strncpy (field_name.ptr, suffix, end - suffix);
 	  field_name.ptr[end - suffix] = '\000';
 	  suffix = end;
 	  write_exp_elt_opcode (STRUCTOP_STRUCT);
 	  write_exp_string (field_name);
-	  write_exp_elt_opcode (STRUCTOP_STRUCT); 	  
+	  write_exp_elt_opcode (STRUCTOP_STRUCT);
 	  break;
 	}
-	  
+
       default:
 	goto BadEncoding;
       }
@@ -944,15 +856,15 @@ write_object_renaming (orig_left_context
 
  BadEncoding:
   error ("Internal error in encoding of renaming declaration: %s",
-	 DEPRECATED_SYMBOL_NAME (renaming));
+	 SYMBOL_LINKAGE_NAME (renaming));
 }
 
 /* Convert the character literal whose ASCII value would be VAL to the
    appropriate value of type TYPE, if there is a translation.
-   Otherwise return VAL.  Hence, in an enumeration type ('A', 'B'), 
-   the literal 'A' (VAL == 65), returns 0. */
+   Otherwise return VAL.  Hence, in an enumeration type ('A', 'B'),
+   the literal 'A' (VAL == 65), returns 0.  */
 static LONGEST
-convert_char_literal (struct type* type, LONGEST val)
+convert_char_literal (struct type *type, LONGEST val)
 {
   char name[7];
   int f;
@@ -960,10 +872,16 @@ convert_char_literal (struct type* type,
   if (type == NULL || TYPE_CODE (type) != TYPE_CODE_ENUM)
     return val;
   sprintf (name, "QU%02x", (int) val);
-  for (f = 0; f < TYPE_NFIELDS (type); f += 1) 
+  for (f = 0; f < TYPE_NFIELDS (type); f += 1)
     {
-      if (DEPRECATED_STREQ (name, TYPE_FIELD_NAME (type, f)))
+      if (strcmp (name, TYPE_FIELD_NAME (type, f)) == 0)
 	return TYPE_FIELD_BITPOS (type, f);
     }
   return val;
 }
+
+void
+_initialize_ada_exp (void)
+{
+  obstack_init (&temp_parse_space);
+}
Index: gdb/ada-lex.l
===================================================================
RCS file: /cvs/src/src/gdb/ada-lex.l,v
retrieving revision 1.3
diff -u -p -r1.3 ada-lex.l
--- gdb/ada-lex.l	23 Nov 2003 20:41:16 -0000	1.3
+++ gdb/ada-lex.l	2 Jun 2004 09:52:56 -0000
@@ -1,5 +1,5 @@
 /* FLEX lexer for Ada expressions, for GDB.
-   Copyright (C) 1994, 1997, 2000
+   Copyright (C) 1994, 1997, 1998, 2000, 2001, 2002, 2003
    Free Software Foundation, Inc.
 
 This file is part of GDB.
@@ -45,20 +45,23 @@ EXP	(e[+-]{NUM10})
 POSEXP  (e"+"?{NUM10})
 
 %{
+#define malloc xmalloc
+#define free xfree
+
 #define NUMERAL_WIDTH 256
 #define LONGEST_SIGN ((ULONGEST) 1 << (sizeof(LONGEST) * HOST_CHAR_BIT - 1))
 
-/* Temporary staging for numeric literals. */
-static char numbuf[NUMERAL_WIDTH]; 
- static void canonicalizeNumeral (char* s1, const char*);
-static int processInt (const char*, const char*, const char*);
-static int processReal (const char*);
-static int processId (const char*, int);
-static int processAttribute (const char*);
-static int find_dot_all (const char*);
+/* Temporary staging for numeric literals.  */
+static char numbuf[NUMERAL_WIDTH];
+ static void canonicalizeNumeral (char *s1, const char *);
+static int processInt (const char *, const char *, const char *);
+static int processReal (const char *);
+static int processId (const char *, int);
+static int processAttribute (const char *);
+static int find_dot_all (const char *);
 
 #undef YY_DECL
-#define YY_DECL static int yylex ( void ) 
+#define YY_DECL static int yylex ( void )
 
 #undef YY_INPUT
 #define YY_INPUT(BUF, RESULT, MAX_SIZE) \
@@ -74,15 +77,15 @@ static int find_dot_all (const char*);
 static char *tempbuf = NULL;
 static int tempbufsize = 0;
 static int tempbuf_len;
-static struct block* left_block_context;
+static struct block *left_block_context;
 
 static void resize_tempbuf (unsigned int);
 
-static void block_lookup (char*, char*);
+static void block_lookup (char *, char *);
 
-static int name_lookup (char*, char*, int*);
+static int name_lookup (char *, char *, int *, int);
 
-static int find_dot_all (const char*);
+static int find_dot_all (const char *);
 
 %}
 
@@ -94,20 +97,20 @@ static int find_dot_all (const char*);
 
 "--".*		 { yyterminate(); }
 
-{NUM10}{POSEXP}  { 
-		   canonicalizeNumeral (numbuf, yytext); 
+{NUM10}{POSEXP}  {
+		   canonicalizeNumeral (numbuf, yytext);
 		   return processInt (NULL, numbuf, strrchr(numbuf, 'e')+1);
 		 }
 
-{NUM10}          { 
-		   canonicalizeNumeral (numbuf, yytext); 
+{NUM10}          {
+		   canonicalizeNumeral (numbuf, yytext);
 		   return processInt (NULL, numbuf, NULL);
 		 }
 
 {NUM10}"#"{HEXDIG}({HEXDIG}|_)*"#"{POSEXP} {
 		   canonicalizeNumeral (numbuf, yytext);
     		   return processInt (numbuf,
-				      strchr (numbuf, '#') + 1, 
+				      strchr (numbuf, '#') + 1,
 				      strrchr(numbuf, '#') + 1);
 		 }
 
@@ -123,12 +126,12 @@ static int find_dot_all (const char*);
 
 
 {NUM10}"."{NUM10}{EXP} {
-		   canonicalizeNumeral (numbuf, yytext); 
+		   canonicalizeNumeral (numbuf, yytext);
 		   return processReal (numbuf);
 		}
 
 {NUM10}"."{NUM10} {
-		   canonicalizeNumeral (numbuf, yytext); 
+		   canonicalizeNumeral (numbuf, yytext);
 		   return processReal (numbuf);
 		}
 
@@ -156,7 +159,7 @@ static int find_dot_all (const char*);
 
 \"{OPER}\"/{WHITE}*"(" { return processId (yytext, yyleng); }
 
-<INITIAL>\"	{ 
+<INITIAL>\"	{
 		   tempbuf_len = 0;
 		   BEGIN IN_STRING;
 		}
@@ -188,10 +191,10 @@ static int find_dot_all (const char*);
 		   tempbuf_len += yyleng-4;
 		}
 
-if		{ 
-		  while (*lexptr != 'i' && *lexptr != 'I') 
-		    lexptr -= 1; 
-		  yyrestart(NULL); 
+if		{
+		  while (*lexptr != 'i' && *lexptr != 'I')
+		    lexptr -= 1;
+		  yyrestart(NULL);
 		  return 0;
 		}
 
@@ -234,51 +237,53 @@ xor		{ return XOR; }
 		      yyrestart(NULL);
 		      return 0;
 		    }
-		  else 
+		  else
 		    return ',';
 		}
 
 "("		{ paren_depth += 1; return '('; }
-")"		{ if (paren_depth == 0) 
+")"		{ if (paren_depth == 0)
 		    {
 		      lexptr -= 1;
 		      yyrestart(NULL);
 		      return 0;
 		    }
-		  else 
+		  else
  		    {
-		      paren_depth -= 1; 
+		      paren_depth -= 1;
 		      return ')';
 		    }
 		}
 
 "."{WHITE}*all  { return DOT_ALL; }
 
-"."{WHITE}*{ID} { 
+"."{WHITE}*{ID} {
 	 	  processId (yytext+1, yyleng-1);
-	          return DOT_ID; 
+	          return DOT_ID;
 		}
 
-{ID}({WHITE}*"."{WHITE}*({ID}|\"{OPER}\"))*(" "*"'")?  { 
+{ID}({WHITE}*"."{WHITE}*({ID}|\"{OPER}\"))*(" "*"'")?  {
                   int all_posn = find_dot_all (yytext);
 		  int token_type, segments, k;
 		  int quote_follows;
 
-                  if (all_posn == -1 && yytext[yyleng-1] == '\'') 
+                  if (all_posn == -1 && yytext[yyleng-1] == '\'')
 		    {
 		      quote_follows = 1;
-		      do { 
-			yyless (yyleng-1); 
+		      do {
+			yyless (yyleng-1);
 		      } while (yytext[yyleng-1] == ' ');
 		    }
 		  else
-		    quote_follows = 0;			
-		    
+		    quote_follows = 0;
+
                   if (all_posn >= 0)
 		    yyless (all_posn);
                   processId(yytext, yyleng);
-                  segments = name_lookup (ada_mangle (yylval.ssym.stoken.ptr),
-		                          yylval.ssym.stoken.ptr, &token_type);
+                  segments = name_lookup (ada_encode (yylval.ssym.stoken.ptr),
+		                          yylval.ssym.stoken.ptr, 
+                                          &token_type,
+					  MAX_RENAMING_CHAIN_LENGTH);
 		  left_block_context = NULL;
 		  for (k = yyleng; segments > 0 && k > 0; k -= 1)
                     {
@@ -289,7 +294,7 @@ xor		{ return XOR; }
 		  if (k <= 0)
 		    error ("confused by name %s", yytext);
 		  yyless (k);
-		  if (quote_follows) 
+		  if (quote_follows)
 		    BEGIN BEFORE_QUAL_QUOTE;
 		  return token_type;
                 }
@@ -303,37 +308,21 @@ xor		{ return XOR; }
                   return BLOCKNAME;
 		}
 
-{ID}({WHITE}*"."{WHITE}*({ID}|\"{OPER}\"))*{WHITE}*::  { 
+{ID}({WHITE}*"."{WHITE}*({ID}|\"{OPER}\"))*{WHITE}*::  {
                   processId(yytext, yyleng-2);
-                  block_lookup (ada_mangle (yylval.ssym.stoken.ptr),
+                  block_lookup (ada_encode (yylval.ssym.stoken.ptr),
                                 yylval.ssym.stoken.ptr);
                   return BLOCKNAME;
 		}
 
 [{}@]		{ return yytext[0]; }
 
-"$$"		{ yylval.lval = -1; return LAST; }
-"$$"{DIG}+	{ yylval.lval = -atoi(yytext+2); return LAST; }
-"$"		{ yylval.lval = 0; return LAST; }
-"$"{DIG}+	{ yylval.lval = atoi(yytext+1); return LAST; }
-
-
 	/* REGISTERS AND GDB CONVENIENCE VARIABLES */
 
-"$"({LETTER}|{DIG}|"$")+  {
-    		  int c;
-		  for (c = 0; c < NUM_REGS; c++)
-		    if (REGISTER_NAME (c) &&
-                        strcmp (yytext + 1, REGISTER_NAME (c)) == 0)
-		      {
-			yylval.lval = c;
-			return REGNAME;
-		      }
+"$"({LETTER}|{DIG}|"$")*  {
 		  yylval.sval.ptr = yytext;
 		  yylval.sval.length = yyleng;
-		  yylval.ivar = 
-		    lookup_internalvar (copy_name (yylval.sval) + 1);
-		  return INTERNAL_VARIABLE;
+		  return SPECIAL_VARIABLE;
 		}
 
 	/* CATCH-ALL ERROR CASE */
@@ -346,34 +335,31 @@ xor		{ return XOR; }
 
 /* Initialize the lexer for processing new expression */
 void
-lexer_init (FILE* inp)
+lexer_init (FILE *inp)
 {
   BEGIN INITIAL;
   yyrestart (inp);
 }
 
 
-/* Make sure that tempbuf points at an array at least N characters long. */
+/* Make sure that tempbuf points at an array at least N characters long.  */
 
 static void
-resize_tempbuf (n)
-     unsigned int n;
+resize_tempbuf (unsigned int n)
 {
   if (tempbufsize < n)
     {
       tempbufsize = (n+63) & ~63;
-      tempbuf = (char*) xrealloc (tempbuf, tempbufsize);
+      tempbuf = (char *) xrealloc (tempbuf, tempbufsize);
     }
 }
- 
-/* Copy S2 to S1, removing all underscores, and downcasing all letters. */
+
+/* Copy S2 to S1, removing all underscores, and downcasing all letters.  */
 
 static void
-canonicalizeNumeral (s1,s2)
-     char* s1;
-     const char* s2;
+canonicalizeNumeral (char *s1, const char *s2)
 {
-  for (; *s2 != '\000'; s2 += 1) 
+  for (; *s2 != '\000'; s2 += 1)
     {
       if (*s2 != '_')
 	{
@@ -386,25 +372,22 @@ canonicalizeNumeral (s1,s2)
 
 #define HIGH_BYTE_POSN ((sizeof (ULONGEST) - 1) * HOST_CHAR_BIT)
 
-/* True (non-zero) iff DIGIT is a valid digit in radix BASE, 
+/* True (non-zero) iff DIGIT is a valid digit in radix BASE,
    where 2 <= BASE <= 16.  */
 
 static int
-is_digit_in_base (digit, base)
-     unsigned char digit;
-     int base;
+is_digit_in_base (unsigned char digit, int base)
 {
   if (!isxdigit (digit))
     return 0;
   if (base <= 10)
     return (isdigit (digit) && digit < base + '0');
-  else 
+  else
     return (isdigit (digit) || tolower (digit) < base - 10 + 'a');
 }
 
 static int
-digit_to_int (c)
-     unsigned char c;
+digit_to_int (unsigned char c)
 {
   if (isdigit (c))
     return c - '0';
@@ -412,12 +395,9 @@ digit_to_int (c)
     return tolower (c) - 'a' + 10;
 }
 
-/* As for strtoul, but for ULONGEST results. */
+/* As for strtoul, but for ULONGEST results.  */
 ULONGEST
-strtoulst (num, trailer, base)
-     const char *num;
-     const char **trailer;
-     int base;
+strtoulst (const char *num, const char **trailer, int base)
 {
   unsigned int high_part;
   ULONGEST result;
@@ -437,7 +417,7 @@ strtoulst (num, trailer, base)
       result = result*base + digit_to_int (num[i]);
       high_part = high_part*base + (unsigned int) (result >> HIGH_BYTE_POSN);
       result &= ((ULONGEST) 1 << HIGH_BYTE_POSN) - 1;
-      if (high_part > 0xff) 
+      if (high_part > 0xff)
 	{
 	  errno = ERANGE;
 	  result = high_part = 0;
@@ -456,26 +436,23 @@ strtoulst (num, trailer, base)
 /* Interprets the prefix of NUM that consists of digits of the given BASE
    as an integer of that BASE, with the string EXP as an exponent.
    Puts value in yylval, and returns INT, if the string is valid.  Causes
-   an error if the number is improperly formated.   BASE, if NULL, defaults 
-   to "10", and EXP to "1". The EXP does not contain a leading 'e' or 'E'. */
+   an error if the number is improperly formated.   BASE, if NULL, defaults
+   to "10", and EXP to "1".  The EXP does not contain a leading 'e' or 'E'.  */
 
 static int
-processInt (base0, num0, exp0)
-     const char* num0;
-     const char* base0;
-     const char* exp0;
+processInt (const char *base0, const char *num0, const char *exp0)
 {
   ULONGEST result;
   long exp;
   int base;
 
-  char* trailer;
+  char *trailer;
 
   if (base0 == NULL)
     base = 10;
   else
-    {	
-      base = strtol (base0, (char**) NULL, 10);
+    {
+      base = strtol (base0, (char **) NULL, 10);
       if (base < 2 || base > 16)
 	error ("Invalid base: %d.", base);
     }
@@ -483,23 +460,23 @@ processInt (base0, num0, exp0)
   if (exp0 == NULL)
     exp = 0;
   else
-    exp = strtol(exp0, (char**) NULL, 10);
+    exp = strtol(exp0, (char **) NULL, 10);
 
   errno = 0;
-  result = strtoulst (num0, &trailer, base);
+  result = strtoulst (num0, (const char **) &trailer, base);
   if (errno == ERANGE)
     error ("Integer literal out of range");
   if (isxdigit(*trailer))
     error ("Invalid digit `%c' in based literal", *trailer);
 
-  while (exp > 0) 
+  while (exp > 0)
     {
       if (result > (ULONG_MAX / base))
 	error ("Integer literal out of range");
       result *= base;
       exp -= 1;
     }
-    
+
   if ((result >> (TARGET_INT_BIT-1)) == 0)
     yylval.typed_val.type = builtin_type_ada_int;
   else if ((result >> (TARGET_LONG_BIT-1)) == 0)
@@ -507,48 +484,47 @@ processInt (base0, num0, exp0)
   else if (((result >> (TARGET_LONG_BIT-1)) >> 1) == 0)
     {
       /* We have a number representable as an unsigned integer quantity.
-         For consistency with the C treatment, we will treat it as an 
+         For consistency with the C treatment, we will treat it as an
 	 anonymous modular (unsigned) quantity.  Alas, the types are such
-	 that we need to store .val as a signed quantity.  Sorry 
+	 that we need to store .val as a signed quantity.  Sorry
          for the mess, but C doesn't officially guarantee that a simple
          assignment does the trick (no, it doesn't; read the reference manual).
        */
       yylval.typed_val.type = builtin_type_unsigned_long;
       if (result & LONGEST_SIGN)
-	yylval.typed_val.val = 
-	  (LONGEST) (result & ~LONGEST_SIGN) 
+	yylval.typed_val.val =
+	  (LONGEST) (result & ~LONGEST_SIGN)
 	  - (LONGEST_SIGN>>1) - (LONGEST_SIGN>>1);
       else
 	yylval.typed_val.val = (LONGEST) result;
       return INT;
     }
-  else 
+  else
     yylval.typed_val.type = builtin_type_ada_long_long;
 
   yylval.typed_val.val = (LONGEST) result;
   return INT;
 }
 
+#if defined (PRINTF_HAS_LONG_DOUBLE)
+#  undef PRINTF_HAS_LONG_DOUBLE
+#  define PRINTF_HAS_LONG_DOUBLE 1
+#else
+#  define PRINTF_HAS_LONG_DOUBLE 0
+#endif
+
 static int
-processReal (num0)
-     const char* num0;
+processReal (const char *num0)
 {
-  if (sizeof (DOUBLEST) <= sizeof (float))
-    sscanf (num0, "%g", &yylval.typed_val_float.dval);
-  else if (sizeof (DOUBLEST) <= sizeof (double))
-    sscanf (num0, "%lg", &yylval.typed_val_float.dval);
+#if defined (PRINTF_HAS_LONG_DOUBLE)
+  if (sizeof (DOUBLEST) > sizeof (double))
+    sscanf (num0, "%Lg", &yylval.typed_val_float.dval);
   else
+#endif
     {
-#ifdef PRINTF_HAS_LONG_DOUBLE
-      sscanf (num0, "%Lg", &yylval.typed_val_float.dval);
-#else
-      /* Scan it into a double, then convert and assign it to the 
-	 long double.  This at least wins with values representable 
-	 in the range of doubles. */
       double temp;
       sscanf (num0, "%lg", &temp);
       yylval.typed_val_float.dval = temp;
-#endif
     }
 
   yylval.typed_val_float.type = builtin_type_ada_float;
@@ -561,26 +537,22 @@ processReal (num0)
 }
 
 static int
-processId (name0, len)
-     const char *name0;
-     int len;
+processId (const char *name0, int len)
 {
-  char* name = xmalloc (len + 11);
+  char *name = obstack_alloc (&temp_parse_space, len + 11);
   int i0, i;
-  
-/*  add_name_string_cleanup (name); */
-/* FIXME: add_name_string_cleanup should be defined in parse.c */
+
   while (len > 0 && isspace (name0[len-1]))
     len -= 1;
   i = i0 = 0;
-  while (i0 < len) 
+  while (i0 < len)
     {
       if (isalnum (name0[i0]))
 	{
 	  name[i] = tolower (name0[i0]);
 	  i += 1; i0 += 1;
 	}
-      else switch (name0[i0]) 
+      else switch (name0[i0])
 	{
 	default:
 	  name[i] = name0[i0];
@@ -617,19 +589,16 @@ processId (name0, len)
   return NAME;
 }
 
-static void 
-block_lookup (name, err_name)
-     char* name;
-     char* err_name;
+static void
+block_lookup (char *name, char *err_name)
 {
-  struct symbol** syms;
-  struct block** blocks;
+  struct ada_symbol_info *syms;
   int nsyms;
   struct symtab *symtab;
   nsyms = ada_lookup_symbol_list (name, left_block_context,
-				  VAR_DOMAIN, &syms, &blocks);
+				  VAR_DOMAIN, &syms);
   if (left_block_context == NULL &&
-      (nsyms == 0 || SYMBOL_CLASS (syms[0]) != LOC_BLOCK))
+      (nsyms == 0 || SYMBOL_CLASS (syms[0].sym) != LOC_BLOCK))
     symtab = lookup_symtab (name);
   else
     symtab = NULL;
@@ -637,72 +606,85 @@ block_lookup (name, err_name)
   if (symtab != NULL)
     left_block_context = yylval.bval =
       BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), STATIC_BLOCK);
-  else if (nsyms == 0 || SYMBOL_CLASS (syms[0]) != LOC_BLOCK)
+  else if (nsyms == 0 || SYMBOL_CLASS (syms[0].sym) != LOC_BLOCK)
     {
       if (left_block_context == NULL)
 	error ("No file or function \"%s\".", err_name);
       else
 	error ("No function \"%s\" in specified context.", err_name);
     }
-  else 
+  else
     {
-      left_block_context = yylval.bval = SYMBOL_BLOCK_VALUE (syms[0]); 
+      left_block_context = yylval.bval = SYMBOL_BLOCK_VALUE (syms[0].sym);
       if (nsyms > 1)
 	warning ("Function name \"%s\" ambiguous here", err_name);
     }
 }
 
-/* Look up NAME0 (assumed to be mangled) as a name in VAR_DOMAIN,
+/* Look up NAME0 (assumed to be encoded) as a name in VAR_DOMAIN,
    setting *TOKEN_TYPE to NAME or TYPENAME, depending on what is
-   found.  Try first the entire name, then the name without the last 
+   found.  Try first the entire name, then the name without the last
    segment (i.e., after the last .id), etc., and return the number of
-   segments that had to be removed to get a match.  Calls error if no
+   segments that had to be removed to get a match.  Try only the full
+   name if it starts with "standard__".  Calls error if no
    matches are found, using ERR_NAME in any error message.  When
-   exactly one symbol match is found, it is placed in yylval. */
- 
+   exactly one symbol match is found, it is placed in yylval.  When
+   the symbol is a renaming, follow at most DEPTH steps to find the  
+   ultimate definition; cause error if depth exceeded.  */
+
 static int
-name_lookup (name0, err_name, token_type)
-     char* name0;
-     char* err_name;
-     int* token_type;
-{
-  struct symbol** syms;
-  struct block** blocks;
-  struct type* type;
+name_lookup (char *name0, char *err_name, int *token_type, int depth)
+{
+  struct ada_symbol_info *syms;
+  struct type *type;
   int len0 = strlen (name0);
-  char* name = savestring (name0, len0);
+  char *name = obsavestring (name0, len0, &temp_parse_space);
   int nsyms;
   int segments;
- 
-/*  add_name_string_cleanup (name);*/
-/* FIXME: add_name_string_cleanup should be defined in parse.c */
+
+  if (depth <= 0)
+    error ("Could not find renamed symbol \"%s\"", err_name);
+
   yylval.ssym.stoken.ptr = name;
   yylval.ssym.stoken.length = strlen (name);
   for (segments = 0; ; segments += 1)
     {
-      struct type* preferred_type;
+      struct type *preferred_type;
       int i, preferred_index;
 
-      if (left_block_context == NULL) 
-	nsyms = ada_lookup_symbol_list (name, expression_context_block, 
-					VAR_DOMAIN, &syms, &blocks);
+      if (left_block_context == NULL)
+	nsyms = ada_lookup_symbol_list (name, expression_context_block,
+					VAR_DOMAIN, &syms);
       else
-	nsyms = ada_lookup_symbol_list (name, left_block_context, 
-					VAR_DOMAIN, &syms, &blocks);
+	nsyms = ada_lookup_symbol_list (name, left_block_context,
+					VAR_DOMAIN, &syms);
+
 
-      /* Check for a type definition. */
+      /* Check for a type renaming.  */
+
+      if (nsyms == 1 && !ada_is_object_renaming (syms[0].sym))
+        {
+          struct symbol *renaming_sym =
+            ada_find_renaming_symbol (SYMBOL_LINKAGE_NAME (syms[0].sym), 
+				      syms[0].block);
+
+          if (renaming_sym != NULL)
+            syms[0].sym = renaming_sym;
+        }
+
+      /* Check for a type definition.  */
 
       /* Look for a symbol that doesn't denote void.  This is (I think) a */
-      /* temporary kludge to get around problems in GNAT output. */
+      /* temporary kludge to get around problems in GNAT output.  */
       preferred_index = -1; preferred_type = NULL;
       for (i = 0; i < nsyms; i += 1)
-	switch (SYMBOL_CLASS (syms[i])) 
+	switch (SYMBOL_CLASS (syms[i].sym))
 	  {
 	  case LOC_TYPEDEF:
-	    if (ada_prefer_type (SYMBOL_TYPE (syms[i]), preferred_type))
+	    if (ada_prefer_type (SYMBOL_TYPE (syms[i].sym), preferred_type))
 	      {
 		preferred_index = i;
-		preferred_type = SYMBOL_TYPE (syms[i]);
+		preferred_type = SYMBOL_TYPE (syms[i].sym);
 	      }
 	    break;
 	  case LOC_REGISTER:
@@ -714,37 +696,38 @@ name_lookup (name0, err_name, token_type
 	  case LOC_LOCAL_ARG:
 	  case LOC_BASEREG:
 	  case LOC_BASEREG_ARG:
+          case LOC_COMPUTED:
+          case LOC_COMPUTED_ARG:
 	    goto NotType;
 	  default:
 	    break;
 	  }
       if (preferred_type != NULL)
 	{
-/*	  if (TYPE_CODE (preferred_type) == TYPE_CODE_VOID)
-	    error ("`%s' matches only void type name(s)", 
-		   ada_demangle (name));
-*/
-/* FIXME: ada_demangle should be defined in defs.h, and is located in ada-lang.c */
-/*	  else*/ if (ada_is_object_renaming (syms[preferred_index]))
+	  if (TYPE_CODE (preferred_type) == TYPE_CODE_VOID)
+	    error ("`%s' matches only void type name(s)",
+		   ada_decode (name));
+	  else if (ada_is_object_renaming (syms[preferred_index].sym))
 	    {
-	      yylval.ssym.sym = syms[preferred_index];
+	      yylval.ssym.sym = syms[preferred_index].sym;
 	      *token_type = OBJECT_RENAMING;
 	      return segments;
-	    } 
-	  else if (ada_renaming_type (SYMBOL_TYPE (syms[preferred_index])) 
+	    }
+	  else if (ada_renaming_type (SYMBOL_TYPE (syms[preferred_index].sym))
                    != NULL)
 	    {
 	      int result;
-	      const char* renaming = 
-		ada_simple_renamed_entity (syms[preferred_index]);
-	      char* new_name = xmalloc (strlen (renaming) + len0 
-					- yylval.ssym.stoken.length + 1);
-/*	      add_name_string_cleanup (new_name);*/
-/* FIXME: add_name_string_cleanup should be defined in parse.c */
+	      char *renaming
+		= ada_simple_renamed_entity (syms[preferred_index].sym);
+	      char *new_name
+                = (char *) obstack_alloc (&temp_parse_space,
+                                          strlen (renaming) + len0
+				          - yylval.ssym.stoken.length + 1);
 	      strcpy (new_name, renaming);
+              free (renaming);
 	      strcat (new_name, name0 + yylval.ssym.stoken.length);
-	      result = name_lookup (new_name, err_name, token_type);
-	      if (result > segments) 
+	      result = name_lookup (new_name, err_name, token_type, depth - 1);
+	      if (result > segments)
 		error ("Confused by renamed symbol.");
 	      return result;
 	    }
@@ -753,16 +736,29 @@ name_lookup (name0, err_name, token_type
 	      yylval.tval = preferred_type;
 	      *token_type = TYPENAME;
 	      return 0;
-	    } 
+	    }
 	}
 
       if (segments == 0)
 	{
 	  type = lookup_primitive_typename (name);
-	  if (type == NULL && DEPRECATED_STREQ ("system__address", name))
+	  if (type == NULL && strcmp ("system__address", name) == 0)
 	    type = builtin_type_ada_system_address;
 	  if (type != NULL)
 	    {
+	      /* First check to see if we have a regular definition of this
+		 type that just didn't happen to have been read yet.  */
+	      int ntypes;
+	      struct symbol *sym;
+	      char *expanded_name = 
+		(char *) alloca (strlen (name) + sizeof ("standard__"));
+	      strcpy (expanded_name, "standard__");
+	      strcat (expanded_name, name);
+	      sym = ada_lookup_symbol (expanded_name, NULL,
+				       VAR_DOMAIN, NULL, NULL);
+	      if (sym != NULL && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
+		type = SYMBOL_TYPE (sym);
+					  
 	      yylval.tval = type;
 	      *token_type = TYPENAME;
 	      return 0;
@@ -770,17 +766,17 @@ name_lookup (name0, err_name, token_type
 	}
 
     NotType:
-      if (nsyms == 1) 
+      if (nsyms == 1)
 	{
 	  *token_type = NAME;
-	  yylval.ssym.sym = syms[0];
+	  yylval.ssym.sym = syms[0].sym;
 	  yylval.ssym.msym = NULL;
-	  yylval.ssym.block = blocks[0];
+	  yylval.ssym.block = syms[0].block;
 	  return segments;
 	}
       else if (nsyms == 0) {
 	int i;
-	yylval.ssym.msym = ada_lookup_minimal_symbol (name);
+	yylval.ssym.msym = ada_lookup_simple_minsym (name);
 	if (yylval.ssym.msym != NULL)
 	  {
 	    yylval.ssym.sym = NULL;
@@ -789,10 +785,14 @@ name_lookup (name0, err_name, token_type
 	    return segments;
 	  }
 
+	if (segments == 0 
+	    && strncmp (name, "standard__", sizeof ("standard__") - 1) == 0)
+	  error ("No definition of \"%s\" found.", err_name);
+
 	for (i = yylval.ssym.stoken.length - 1; i > 0; i -= 1)
 	  {
             if (name[i] == '.')
-	      { 
+	      {
 		name[i] = '\0';
 		yylval.ssym.stoken.length = i;
 		break;
@@ -805,20 +805,20 @@ name_lookup (name0, err_name, token_type
 		break;
 	      }
 	  }
-	if (i <= 0) 
+	if (i <= 0)
 	  {
 	    if (!have_full_symbols () && !have_partial_symbols ()
 		&& left_block_context == NULL)
 	      error ("No symbol table is loaded.  Use the \"file\" command.");
 	    if (left_block_context == NULL)
-	      error ("No definition of \"%s\" in current context.", 
+	      error ("No definition of \"%s\" in current context.",
 		     err_name);
 	    else
-	      error ("No definition of \"%s\" in specified context.", 
+	      error ("No definition of \"%s\" in specified context.",
 		     err_name);
 	  }
       }
-      else 
+      else
 	{
 	  *token_type = NAME;
 	  yylval.ssym.sym = NULL;
@@ -833,10 +833,9 @@ name_lookup (name0, err_name, token_type
 }
 
 /* Returns the position within STR of the '.' in a
-   '.{WHITE}*all' component of a dotted name, or -1 if there is none. */
+   '.{WHITE}*all' component of a dotted name, or -1 if there is none.  */
 static int
-find_dot_all (str)
-     const char* str;
+find_dot_all (const char *str)
 {
   int i;
   for (i = 0; str[i] != '\000'; i += 1)
@@ -844,7 +843,7 @@ find_dot_all (str)
       if (str[i] == '.')
 	{
 	  int i0 = i;
-	  do 
+	  do
 	    i += 1;
 	  while (isspace (str[i]));
 	  if (strcmp (str+i, "all") == 0
@@ -853,15 +852,13 @@ find_dot_all (str)
 	}
     }
   return -1;
-}    
+}
 
 /* Returns non-zero iff string SUBSEQ matches a subsequence of STR, ignoring
-   case. */
+   case.  */
 
 static int
-subseqMatch (subseq, str)
-     const char* subseq;
-     const char* str;
+subseqMatch (const char *subseq, const char *str)
 {
   if (subseq[0] == '\0')
     return 1;
@@ -872,9 +869,9 @@ subseqMatch (subseq, str)
   else
     return subseqMatch (subseq, str+1);
 }
-  
 
-static struct { const char* name; int code; } 
+
+static struct { const char *name; int code; }
 attributes[] = {
   { "address", TICK_ADDRESS },
   { "unchecked_access", TICK_ACCESS },
@@ -898,8 +895,7 @@ attributes[] = {
    abbreviation STR.  */
 
 static int
-processAttribute (str)
-     const char* str;
+processAttribute (const char *str)
 {
   int i, k;
 
@@ -908,11 +904,11 @@ processAttribute (str)
       return attributes[i].code;
 
   for (i = 0, k = -1; attributes[i].code != -1; i += 1)
-    if (subseqMatch (str, attributes[i].name)) 
+    if (subseqMatch (str, attributes[i].name))
       {
 	if (k == -1)
 	  k = i;
-	else 
+	else
 	  error ("ambiguous attribute name: `%s'", str);
       }
   if (k == -1)
@@ -922,7 +918,7 @@ processAttribute (str)
 }
 
 int
-yywrap()
+yywrap(void)
 {
   return 1;
 }

