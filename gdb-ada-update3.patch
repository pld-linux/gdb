From gdb-patches-return-33535-listarch-gdb-patches=sources dot redhat dot com at sources dot redhat dot com Wed Jun 02 10:06:52 2004
Return-Path: <gdb-patches-return-33535-listarch-gdb-patches=sources dot redhat dot com at sources dot redhat dot com>
Delivered-To: listarch-gdb-patches at sources dot redhat dot com
Received: (qmail 7737 invoked by alias); 2 Jun 2004 10:06:52 -0000
Mailing-List: contact gdb-patches-help at sources dot redhat dot com; run by ezmlm
Precedence: bulk
List-Subscribe: <mailto:gdb-patches-subscribe at sources dot redhat dot com>
List-Archive: <http://sources.redhat.com/ml/gdb-patches/>
List-Post: <mailto:gdb-patches at sources dot redhat dot com>
List-Help: <mailto:gdb-patches-help at sources dot redhat dot com>, <http://sources dot redhat dot com/ml/#faqs>
Sender: gdb-patches-owner at sources dot redhat dot com
Delivered-To: mailing list gdb-patches at sources dot redhat dot com
Received: (qmail 7632 invoked from network); 2 Jun 2004 10:06:33 -0000
Received: from unknown (HELO nile.gnat.com) (205.232.38.5)
  by sourceware dot org with SMTP; 2 Jun 2004 10:06:33 -0000
Received: from localhost (localhost [127.0.0.1])
	by nile dot gnat dot com (Postfix) with ESMTP id 63F48F2854
	for <gdb-patches at sources dot redhat dot com>; Wed,  2 Jun 2004 06:06:32 -0400 (EDT)
Received: from nile.gnat.com ([127.0.0.1])
 by localhost (nile dot gnat dot com [127 dot 0 dot 0 dot 1]) (amavisd-new, port 10024) with LMTP
 id 11617-01-3 for <gdb-patches at sources dot redhat dot com>;
 Wed,  2 Jun 2004 06:06:31 -0400 (EDT)
Received: by nile.gnat.com (Postfix, from userid 1345)
	id 50E19F283F; Wed,  2 Jun 2004 06:06:31 -0400 (EDT)
From: Paul Hilfinger <hilfingr at gnat dot com>
To: gdb-patches at sources dot redhat dot com
Subject: [PATCH]: Updates to Ada sources, part 3 (long)
Message-Id: <20040602100631.50E19F283F@nile.gnat.com>
Date: Wed,  2 Jun 2004 06:06:31 -0400 (EDT)
X-Virus-Scanned: by amavisd-new at nile.gnat.com


Part 3/3 of synchronizing patch with ACT sources.

Paul Hilfinger

Index: gdb/ada-tasks.c
===================================================================
RCS file: /cvs/src/src/gdb/ada-tasks.c,v
retrieving revision 1.8
diff -u -p -r1.8 ada-tasks.c
--- gdb/ada-tasks.c	28 Apr 2004 16:36:25 -0000	1.8
+++ gdb/ada-tasks.c	2 Jun 2004 09:52:56 -0000
@@ -1,10 +1,10 @@
-/* file ada-tasks.c: Ada tasking control for GDB
-   Copyright 1997 Free Software Foundation, Inc.
-   Contributed by Ada Core Technologies, Inc
-.
+/* File ada-tasks.c: Ada tasking control for GDB
+   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
+   Free Software Foundation, Inc.
+   Contributed by Ada Core Technologies, Inc.
+
    This file is part of GDB.
 
-   [$Id$]
    Authors: Roch-Alexandre Nomine Beguin, Arnaud Charlet <charlet@gnat.com>
 
    This program is free software; you can redistribute it and/or modify
@@ -15,6 +15,7 @@
 */
 
 #include <ctype.h>
+#include <gdb_string.h>
 #include "defs.h"
 #include "command.h"
 #include "value.h"
@@ -22,94 +23,294 @@
 #include "inferior.h"
 #include "symtab.h"
 #include "target.h"
-#include "regcache.h"
 #include "gdbcore.h"
+#include "gdbthread.h"
+#include "regcache.h"       /* for registers_changed */
 
-#if (defined(__alpha__) && defined(__osf__) && !defined(__alpha_vxworks))
+#if defined (__fsu__) || defined (HAVE_SPYTHREAD) \
+    || (defined(__alpha__) && defined(__osf__) && !defined(__alpha_vxworks))
 #include <sys/procfs.h>
 #endif
 
-#if (defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET))
+#if defined (__fsu__) || defined (HAVE_SPYTHREAD) \
+    || (defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET))
 #include "gregset.h"
 #endif
 
+#ifdef I386_GNULINUX_TARGET
+#include "gdb_thread_db.h"
+#endif
+
+#if defined (HAVE_SPYTHREAD)
+#include "irix6-spyThread.h"
+#endif
+
 #include "ada-lang.h"
+#include "observer.h"
 
-/* FIXME: move all this conditional compilation in description
-   files or in configure.in */
+enum task_states
+{
+  Unactivated,
+  Runnable,
+  Terminated,
+  Activator_Sleep,
+  Acceptor_Sleep,
+  Entry_Caller_Sleep,
+  Async_Select_Sleep,
+  Delay_Sleep,
+  Master_Completion_Sleep,
+  Master_Phase_2_Sleep
+};
 
-#if defined (VXWORKS_TARGET)
-#define THREAD_TO_PID(tid,lwpid) (tid)
+struct task_control_block
+{
+  char state;
+  CORE_ADDR parent;
+  int priority;
+  char image [32];
+  int image_len;    /* This field is not always present in the ATCB.  */
+  CORE_ADDR call;
+  CORE_ADDR thread;
+  CORE_ADDR lwp;    /* This field is not always present in the ATCB.  */
+};
 
-#elif defined (linux)
-#define THREAD_TO_PID(tid,lwpid) (0)
+/* The index of certain important fields in the Ada Task Control Block
+   record and sub-records.  */
 
-#elif (defined (sun) && defined (__SVR4))
-#define THREAD_TO_PID thread_to_pid
+struct tcb_fieldnos
+{
+  /* Fields in record Ada_Task_Control_Block.  */
+  int common;
 
-#elif defined (sgi) || defined (__WIN32__) || defined (hpux)
-#define THREAD_TO_PID(tid,lwpid) ((int)lwpid)
+  /* Fields in record Common_ATCB.  */
+  int state;
+  int parent;
+  int priority;
+  int image;
+  int image_len;     /* This field may be missing.  */
+  int call;
+  int ll;
+
+  /* Fields in Task_Primitives.Private_Data.  */
+  int ll_thread;
+  int ll_lwp;        /* This field may be missing.  */
+};
 
+#if defined (linux)
+#define TASK_LWP(atcb) 0L
 #else
-#define THREAD_TO_PID(tid,lwpid) (0)
+#define TASK_LWP(atcb) extract_unsigned_integer (&(atcb).lwp, sizeof ((atcb).lwp))
 #endif
 
+struct task_ptid
+{
+  int pid;                      /* The Process id */
+  long lwp;                     /* The Light Weight Process id */
+  long tid;                     /* The Thread id */
+};
+typedef struct task_ptid task_ptid_t;
+
+struct task_entry
+{
+  CORE_ADDR task_id;
+  struct task_control_block atcb;
+  int task_num;
+  int known_tasks_index;
+  struct task_entry *next_task;
+  task_ptid_t task_ptid;
+  int stack_per;
+};
+
+/* FIXME: move all this conditional compilation in description
+   files or in configure.in */
+
 #if defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET)
+#define SPECIAL_THREAD_SUPPORT_ACTIVE() thread_support
+#define SAVE_TASK_REGISTERS(task) \
+  do { fill_gregset (&gregset_saved, -1); \
+       fill_fpregset (&fpregset_saved, -1); \
+  } while (0)
+#define RESTORE_TASK_REGISTERS(task) \
+  do { supply_gregset (&gregset_saved); \
+       supply_fpregset (&fpregset_saved); \
+  } while (0)
+
 #define THREAD_FETCH_REGISTERS dec_thread_fetch_registers
-#define GET_CURRENT_THREAD dec_thread_get_current_thread
+#define GET_CURRENT_THREAD(PTID) dec_thread_get_current_thread ()
+extern unsigned long dec_thread_get_current_thread (void);
 extern int dec_thread_get_registers (gdb_gregset_t *, gdb_fpregset_t *);
+extern int dec_thread_fetch_registers (void);
 #endif
 
-#if defined (_AIX)
-#define THREAD_FETCH_REGISTERS aix_thread_fetch_registers
-#define GET_CURRENT_THREAD aix_thread_get_current_thread
+#ifdef __fsu__
+#define SPECIAL_THREAD_SUPPORT_ACTIVE() \
+   (thread_support && pthread_kern_addr != 0)
+#define SAVE_TASK_REGISTERS(task) \
+  do { \
+    if (pthread_kern_addr != 0) \
+      { \
+        fill_gregset (&gregset_saved, -1); \
+        fill_fpregset (&fpregset_saved, -1); \
+      } \
+  } while (0)
+#define RESTORE_TASK_REGISTERS(task) \
+  do { \
+    if (pthread_kern_addr != 0) \
+      { \
+        supply_gregset (&gregset_saved); \
+        supply_fpregset (&fpregset_saved); \
+      } \
+  } while (0)
+
+extern int fsu_thread_fetch_registers (void);
+extern unsigned long fsu_thread_get_current_thread (void);
+static int fsu_or_linux_thread_fetch_registers (void);
+static long fsu_or_linux_thread_get_current_thread (ptid_t);
+#define THREAD_FETCH_REGISTERS fsu_or_linux_thread_fetch_registers
+#define GET_CURRENT_THREAD(PTID) fsu_or_linux_thread_get_current_thread (PTID)
+#define PTHREAD_KERN "pthread_kern"
+#endif
+
+#ifdef I386_GNULINUX_TARGET
+extern td_thrinfo_t thread_db_pid_to_thread_info (int pid);
+extern int thread_db_tid_to_pid (void *tid);
 #endif
 
 #if defined(VXWORKS_TARGET)
-#define GET_CURRENT_THREAD() ((void*)inferior_pid)
+#define GET_CURRENT_THREAD(PTID) (unsigned long) ptid_get_pid (PTID)
 #define THREAD_FETCH_REGISTERS() (-1)
 
-#elif defined (sun) && defined (__SVR4)
-#define GET_CURRENT_THREAD solaris_thread_get_current_thread
+#elif defined (__WIN32__) || defined (__CYGWIN__) || defined (hpux)
+#define GET_CURRENT_THREAD(PTID) ptid_get_pid (PTID)
 #define THREAD_FETCH_REGISTERS() (-1)
-extern void *GET_CURRENT_THREAD ();
+#endif
 
-#elif defined (_AIX) || (defined(__alpha__) && defined(__osf__))
-extern void *GET_CURRENT_THREAD ();
+#if defined (HAVE_SPYTHREAD)
+#define GET_CURRENT_THREAD(PTID) (unsigned long) TIDGET (PTID)
+#endif
 
-#elif defined (__WIN32__) || defined (hpux)
-#define GET_CURRENT_THREAD() (inferior_pid)
-#define THREAD_FETCH_REGISTERS() (-1)
+#if !defined(GET_CURRENT_THREAD)
+#define GET_CURRENT_THREAD(PTID) (unsigned long) ptid_get_tid (PTID)
+#endif
 
-#else
-#define GET_CURRENT_THREAD() (NULL)
-#define THREAD_FETCH_REGISTERS() (-1)
+#if !defined(THREAD_FETCH_REGISTERS)
+#define THREAD_FETCH_REGISTERS() (target_fetch_registers (-1), 0)
+#endif
+
+#if !defined(SAVE_TASK_REGISTERS)
+#define SAVE_TASK_REGISTERS(task)
+#define RESTORE_TASK_REGISTERS(task)
+#endif
+
+#if !defined(SPECIAL_THREAD_SUPPORT_ACTIVE)
+#define SPECIAL_THREAD_SUPPORT_ACTIVE() 0
 #endif
 
 #define KNOWN_TASKS_NAME "system__tasking__debug__known_tasks"
 
-#define READ_MEMORY(addr, var) read_memory (addr, (char*) &var, sizeof (var))
-/* external declarations */
+#define READ_MEMORY(addr, var) read_memory (addr, (char *) &var, sizeof (var))
+
+/* If defined to 1, means that the thread ptids maintained by core GDB
+   follow this format : first field (pid) contains the tid
+                       second field (lwp) contains 0
+                       third field (tid) contains 0 */
+#ifndef THREAD_PTID_CONTAINS_TID_NULL_NULL
+#define THREAD_PTID_CONTAINS_TID_NULL_NULL (0)
+#endif
+
+/* If defined to 1, means that the thread ptids maintained by core GDB
+   follow this format: first field (pid) contains the LWP id
+                       second field (lwp) contains 0
+                       third field (tid) contains 0 */
+#ifndef THREAD_PTID_CONTAINS_LWP_NULL_NULL
+#define THREAD_PTID_CONTAINS_LWP_NULL_NULL (0)
+#endif
+
+/* If defined to 1, means that the thread ptids maintained by core GDB
+   follow this format: first field (pid) contains the PID
+                       second field (lwp) contains 0
+                       third field (tid) contains the TID */
+#ifndef THREAD_PTID_CONTAINS_PID_NULL_TID
+#define THREAD_PTID_CONTAINS_PID_NULL_TID (0)
+#endif
+
+/* If defined to 1, means that the thread ptids maintained by core GDB
+   follow this format: first field (pid) contains the PID
+                       second field (lwp) contains the TID
+                       third field (tid) contains the 0 */
+
+#ifndef THREAD_PTID_CONTAINS_PID_TID_NULL
+#define THREAD_PTID_CONTAINS_PID_TID_NULL (0)
+#endif
+
+/* If defined to 1, means that the thread id is not stored in the tid
+   field of the task_ptid, but rather in the lwp field.  */
+#ifndef ADA_THREAD_ID_IN_LWP
+#define ADA_THREAD_ID_IN_LWP (0)
+#endif
+
+static int task_ptid_get_pid (task_ptid_t task_ptid);
+static long task_ptid_get_lwp (task_ptid_t task_ptid);
+static long task_ptid_get_tid (task_ptid_t task_ptid);
+static task_ptid_t task_ptid_build (int pid, long lwp, long tid);
+static ptid_t task_ptid_get_ptid (task_ptid_t task_ptid);
+static long task_ptid_get_thread_id (task_ptid_t task_ptid);
+
+static int task_is_alive (enum task_states state);
+static CORE_ADDR get_self_id (ptid_t);
+static int get_entry_number (CORE_ADDR);
+static void get_tcb_types_info (struct type **atcb_type,
+                                struct type **atcb_common_type,
+                                struct type **atcb_ll_type,
+                                struct tcb_fieldnos *atcb_fieldnos);
+static void get_tcb_call_type_info (struct type **atcb_call_type,
+                                    int *atcb_call_self_fieldno);
+static CORE_ADDR get_known_tasks_addr (void);
+static int read_known_tasks_array (void);
+static int build_task_list (void);
+static void value_as_string (char *dest, struct value *val, int length);
+static struct task_control_block read_atcb (CORE_ADDR atcb_addr);
+static CORE_ADDR read_caller (const CORE_ADDR call);
+static void display_current_task_id (void);
+static void task_command_1 (char *tidstr, int from_tty);
+
+/* Ada-tasks observers.  */
+
+static void normal_stop_notification (void);
+static void ada_tasks_attach_observers (void);
 
 /* Global visible variables */
 
-struct task_entry *task_list = NULL;
 int ada__tasks_check_symbol_table = 1;
-void *pthread_kern_addr = NULL;
+CORE_ADDR pthread_kern_addr = 0;
+
+/* Local global variables.  */
+static struct task_entry *task_list = NULL;
+
+/* When non-zero, this flag indicates that the current task_list
+   is obsolete, and should be recomputed before it is accessed.  */
+static int stale_task_list_p = 1;
 
-#if (defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET))
+#if defined (__fsu__) || (defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET))
 gdb_gregset_t gregset_saved;
 gdb_fpregset_t fpregset_saved;
 #endif
 
 /* The maximum number of tasks known to the Ada runtime */
-const int MAX_NUMBER_OF_KNOWN_TASKS = 1000;
+static const int MAX_NUMBER_OF_KNOWN_TASKS = 1000;
 
-/* the current task */
-int current_task = -1, current_task_id = -1, current_task_index;
-void *current_thread, *current_lwp;
+/* the current task, as seen by the user. Modified everytime the user
+   does a task switch.  */
+static int current_task = -1;
 
-char *ada_task_states[] = {
+unsigned long current_thread;
+
+/* The task where the debugger stopped, giving control back to the user.
+   Not affected by task switching. Used to restore the registers before
+   continuing the inferior.  */
+int current_task_id = -1;
+
+static char *task_states[] = {
   "Unactivated",
   "Runnable",
   "Terminated",
@@ -129,7 +330,7 @@ char *ada_task_states[] = {
 
 /* Global internal types */
 
-static char *ada_long_task_states[] = {
+static char *long_task_states[] = {
   "Unactivated",
   "Runnable",
   "Terminated",
@@ -150,11 +351,34 @@ static char *ada_long_task_states[] = {
 /* Global internal variables */
 
 static int highest_task_num = 0;
-int thread_support = 0;		/* 1 if the thread library in use is supported */
-static int gdbtk_task_initialization = 0;
+static int thread_support = 0;  /* 1 if the thread library in use is
+                                   supported. FIXME: Not reinitialized
+                                   properly when program reloaded.
+                                 */
+#ifdef __fsu__
+static int
+fsu_or_linux_thread_fetch_registers (void)
+{
+  if (pthread_kern_addr != 0)
+    return fsu_thread_fetch_registers ();
+
+  target_fetch_registers (-1);
+  return 0L;
+}
+
+static long
+fsu_or_linux_thread_get_current_thread (ptid_t ptid)
+{
+  if (pthread_kern_addr != 0)
+    return fsu_thread_get_current_thread ();
+
+  return ptid_get_tid (ptid);
+}
+
+#endif /* __fsu__ */
 
 static int
-add_task_entry (void *p_task_id, int index)
+add_task_entry (CORE_ADDR p_task_id, int index)
 {
   struct task_entry *new_task_entry = NULL;
   struct task_entry *pt;
@@ -163,13 +387,18 @@ add_task_entry (void *p_task_id, int ind
   new_task_entry = xmalloc (sizeof (struct task_entry));
   new_task_entry->task_num = highest_task_num;
   new_task_entry->task_id = p_task_id;
+  new_task_entry->atcb = read_atcb (p_task_id);
   new_task_entry->known_tasks_index = index;
+  new_task_entry->task_ptid =
+    task_ptid_build (ptid_get_pid (inferior_ptid), /* ? */
+                                   TASK_LWP (new_task_entry->atcb),
+                                   new_task_entry->atcb.thread);
   new_task_entry->next_task = NULL;
   pt = task_list;
   if (pt)
     {
       while (pt->next_task)
-	pt = pt->next_task;
+        pt = pt->next_task;
       pt->next_task = new_task_entry;
       pt->stack_per = 0;
     }
@@ -178,8 +407,8 @@ add_task_entry (void *p_task_id, int ind
   return new_task_entry->task_num;
 }
 
-int
-get_entry_number (void *p_task_id)
+static int
+get_entry_number (CORE_ADDR p_task_id)
 {
   struct task_entry *pt;
 
@@ -187,22 +416,22 @@ get_entry_number (void *p_task_id)
   while (pt != NULL)
     {
       if (pt->task_id == p_task_id)
-	return pt->task_num;
+        return pt->task_num;
       pt = pt->next_task;
     }
   return 0;
 }
 
 static struct task_entry *
-get_thread_entry_vptr (void *thread)
+get_thread_entry_vptr (long thread)
 {
   struct task_entry *pt;
 
   pt = task_list;
   while (pt != NULL)
     {
-      if (pt->thread == thread)
-	return pt;
+      if (task_ptid_get_thread_id (pt->task_ptid) == thread)
+        return pt;
       pt = pt->next_task;
     }
   return 0;
@@ -217,7 +446,7 @@ get_entry_vptr (int p_task_num)
   while (pt)
     {
       if (pt->task_num == p_task_num)
-	return pt;
+        return pt;
       pt = pt->next_task;
     }
   return NULL;
@@ -228,6 +457,8 @@ init_task_list (void)
 {
   struct task_entry *pt, *old_pt;
 
+  target_find_new_threads ();
+
   pt = task_list;
   while (pt)
     {
@@ -245,64 +476,592 @@ valid_task_id (int task)
   return get_entry_vptr (task) != NULL;
 }
 
-void *
-get_self_id (void)
+/* Return the pid of a given task ptid.  */
+
+static int
+task_ptid_get_pid (task_ptid_t task_ptid)
+{
+  return task_ptid.pid;
+}
+
+/* Return the lwp of a given task ptid.  */
+
+static long
+task_ptid_get_lwp (task_ptid_t task_ptid)
 {
-  struct value *val;
-  void *self_id;
-  int result;
+  return task_ptid.lwp;
+}
+
+/* Return the tid of a given task ptid.  */
+
+static long
+task_ptid_get_tid (task_ptid_t task_ptid)
+{
+  return task_ptid.tid;
+}
+
+/* Build a task ptid from the associated pid, lwp, and tid.  */
+
+static task_ptid_t
+task_ptid_build (int pid, long lwp, long tid)
+{
+  task_ptid_t task_ptid;
+
+  task_ptid.pid = pid;
+  task_ptid.lwp = lwp;
+  task_ptid.tid = tid;
+  return task_ptid;
+}
+
+/* Translate a task ptid into a ptid (the ptid maintained by core GDB).
+
+   On most platforms, they are equivalent, and this function can be
+   regarded as the identity. However, there are other platforms where
+   the task ptid and the ptid are not equivalent. For instance, the task
+   LWP value is sometimes stored by GDB-core as a pid! This translation
+   therefore becomes necessary before invoking the GDB thread services.  */
+
+static ptid_t
+task_ptid_get_ptid (task_ptid_t task_ptid)
+{
+  ptid_t ptid;
+
+  if (THREAD_PTID_CONTAINS_TID_NULL_NULL)
+    ptid = ptid_build (task_ptid_get_tid (task_ptid), 0, 0);
+  else if (THREAD_PTID_CONTAINS_LWP_NULL_NULL)
+    ptid = ptid_build (task_ptid_get_lwp (task_ptid), 0, 0);
+  else if (THREAD_PTID_CONTAINS_PID_NULL_TID)
+    ptid = ptid_build (task_ptid_get_pid (task_ptid),
+                       0, task_ptid_get_tid (task_ptid));
+  else if (THREAD_PTID_CONTAINS_PID_TID_NULL)
+    ptid = ptid_build (task_ptid_get_pid (task_ptid),
+                       task_ptid_get_tid (task_ptid), 0);
+  else
+    ptid = ptid_build (task_ptid_get_pid (task_ptid),
+                       task_ptid_get_lwp (task_ptid),
+                       task_ptid_get_tid (task_ptid));
+
+  return ptid;
+}
+
+/* Extract and return the thread_id for the given TASK_PTID.  */
+
+static long
+task_ptid_get_thread_id (task_ptid_t task_ptid)
+{
+  /* On most platforms, the thread_id is stored in task_ptid.tid.
+     Unfortunately, some other platforms store it as the task_ptid.lwp...  */
+
+  if (ADA_THREAD_ID_IN_LWP)
+    return task_ptid_get_lwp (task_ptid);
+  else
+    return task_ptid_get_tid (task_ptid);
+}
+
+/* Return non-zero iff the task STATE corresponds to a non-terminated
+   task state.  */
+
+static int
+task_is_alive (enum task_states state)
+{
+  return (state != Terminated);
+}
+
+static CORE_ADDR
+get_self_id (ptid_t ptid)
+{
+#ifdef GNAT_GDB
   struct task_entry *ent;
-  extern int do_not_insert_breakpoints;
 
 #if !((defined(sun) && defined(__SVR4)) || defined(VXWORKS_TARGET) || defined(__WIN32__))
   if (thread_support)
 #endif
     {
-      ent = get_thread_entry_vptr (GET_CURRENT_THREAD ());
+      ent = get_thread_entry_vptr (GET_CURRENT_THREAD (ptid));
       return ent ? ent->task_id : 0;
     }
+#endif
 
   /* FIXME: calling a function in the inferior with a multithreaded application
-     is not reliable, so return NULL if there is no safe way to get the current
-     task */
-  return NULL;
+     is not reliable, so return a null address if there is no safe way to
+     get the current task */
+  return 0;
 }
 
 int
-get_current_task (void)
+ada_get_current_task (ptid_t ptid)
 {
   int result;
 
-  /* FIXME: language_ada should be defined in defs.h */
-  /*  if (current_language->la_language != language_ada) return -1; */
+  if (current_language->la_language != language_ada)
+    return -1;
 
-  result = get_entry_number (get_self_id ());
+  result = get_entry_number (get_self_id (ptid));
 
   /* return -1 if not found */
   return result == 0 ? -1 : result;
 }
 
+/* Get from the debugging information the type description of all types
+   related to the Ada Task Control Block that will be needed in order to
+   read the list of known tasks in the Ada runtime.  Also return the
+   associated ATCB_FIELDNOS.
+
+   Error handling:  Any data missing from the debugging info will cause
+   an error to be raised, and none of the return values to be set.
+   Users of this function can depend on the fact that all or none of the
+   return values will be set.  */
+
+static void
+get_tcb_types_info (struct type **atcb_type,
+                    struct type **atcb_common_type,
+                    struct type **atcb_ll_type,
+                    struct tcb_fieldnos *atcb_fieldnos)
+{
+  struct type *type;
+  struct type *common_type;
+  struct type *ll_type;
+  struct tcb_fieldnos fieldnos;
+
+#ifndef ADA_RETAIN_DOTS
+  const char *atcb_name = "system__tasking__ada_task_control_block___XVE";
+  const char *common_atcb_name = "system__tasking__common_atcb";
+  const char *private_data_name = "system__task_primitives__private_data";
+#else
+  const char *atcb_name = "system.tasking.ada_task_control_block___XVE";
+  const char *common_atcb_name = "system.tasking.common_atcb";
+  const char *private_data_name = "system.task_primitives.private_data";
+#endif
+
+  const struct symbol *atcb_sym =
+    lookup_symbol (atcb_name, NULL, VAR_DOMAIN, NULL, NULL);
+  const struct symbol *common_atcb_sym =
+    lookup_symbol (common_atcb_name, NULL, VAR_DOMAIN, NULL, NULL);
+  const struct symbol *private_data_sym =
+    lookup_symbol (private_data_name, NULL, VAR_DOMAIN, NULL, NULL);
+
+  if (atcb_sym == NULL || atcb_sym->type == NULL)
+    error ("Can not find Ada_Task_Control_Block type. Aborting");
+  if (common_atcb_sym == NULL || common_atcb_sym->type == NULL)
+    error ("Can not find Common_ATCB type. Aborting");
+  if (private_data_sym == NULL || private_data_sym->type == NULL)
+    error ("Can not find Private_Data type. Aborting");
+
+  /* Get a static representation of the type record Ada_Task_Control_Block.  */
+  type = atcb_sym->type;
+  type = ada_template_to_fixed_record_type_1 (type, NULL, 0, NULL, 0);
+
+  /* Get the type for Ada_Task_Control_Block.Common.  */
+  common_type = common_atcb_sym->type;
+
+  /* Get the type for Ada_Task_Control_Bloc.Common.Call.LL.  */
+  ll_type = private_data_sym->type;
+
+  /* Get the field indices.  */
+  fieldnos.common = ada_get_field_index (type, "common", 0);
+  fieldnos.state = ada_get_field_index (common_type, "state", 0);
+  fieldnos.parent = ada_get_field_index (common_type, "parent", 0);
+  fieldnos.priority = ada_get_field_index (common_type, "base_priority", 0);
+  fieldnos.image = ada_get_field_index (common_type, "task_image", 0);
+  fieldnos.image_len = ada_get_field_index (common_type, "task_image_len", 1);
+  fieldnos.call = ada_get_field_index (common_type, "call", 0);
+  fieldnos.ll = ada_get_field_index (common_type, "ll", 0);
+  fieldnos.ll_thread = ada_get_field_index (ll_type, "thread", 0);
+  fieldnos.ll_lwp = ada_get_field_index (ll_type, "lwp", 1);
+
+  /* On certain platforms such as x86-windows, the "lwp" field has been
+     named "thread_id".  This field will likely be renamed in the future,
+     but we need to support both possibilities to avoid an unnecessary
+     dependency on a recent compiler.  We therefore try locating the
+     "thread_id" field in place of the "lwp" field if we did not find
+     the latter.  */
+  if (fieldnos.ll_lwp < 0)
+    fieldnos.ll_lwp = ada_get_field_index (ll_type, "thread_id", 1);
+
+  /* Set all the out parameters all at once, now that we are certain
+     that there are no potential error() anymore.  */
+  *atcb_type = type;
+  *atcb_common_type = common_type;
+  *atcb_ll_type = ll_type;
+  *atcb_fieldnos = fieldnos;
+}
+
+/* Get from the debugging information the type description of the
+   record type Entry_Call_Record (this is the type of the field
+   Call.all in the Common_ATCB record type). Also return the index
+   of the field "Self" in Entry_Call_Record.
+
+   Error handling:  Any data missing from the debugging info will cause
+   an error to be raised, and none of the return values to be set.
+   Users of this function can depend on the fact that all or none of the
+   return values will be set.  */
+
+static void
+get_tcb_call_type_info (struct type **atcb_call_type,
+                        int *atcb_call_self_fieldno)
+{
+  struct type *call_type;
+  int call_self_fieldno;
+
+#ifndef ADA_RETAIN_DOTS
+  const char *entry_call_record_name = "system__tasking__entry_call_record";
+#else
+  const char *entry_call_record_name = "system.tasking.entry_call_record";
+#endif
+
+  const struct symbol *entry_call_record_sym =
+    lookup_symbol (entry_call_record_name, NULL, VAR_DOMAIN, NULL, NULL);
+
+  if (entry_call_record_sym == NULL || entry_call_record_sym->type == NULL)
+    error ("Can not find Entry_Call_Record type. Aborting");
+
+  call_type = entry_call_record_sym->type;
+  call_self_fieldno = ada_get_field_index (call_type, "self", 0);
+
+  /* Set all the out parameters all at once, now that we are certain
+     that there are no potential error() anymore.  */
+  *atcb_call_type = call_type;
+  *atcb_call_self_fieldno = call_self_fieldno;
+}
+
+/* Return the address of the Known_Tasks array maintained in
+   the Ada Runtime.  Return NULL if the array could not be found,
+   meaning that the inferior program probably does not use tasking.
+
+   In order to provide a fast response time, this function caches
+   the Known_Tasks array address after the lookup during the first
+   call. Subsequent calls will simply return this cached address.  */
+
+static CORE_ADDR
+get_known_tasks_addr (void)
+{
+  static CORE_ADDR known_tasks_addr = 0;
+
+  if (ada__tasks_check_symbol_table)
+    {
+      struct symbol *sym;
+      struct minimal_symbol *msym;
+
+      thread_support = 0;
+#if (defined(__alpha__) && defined(__osf__) & !defined(VXWORKS_TARGET)) \
+    || defined (_AIX) || defined (__CYGWIN__)
+      thread_support = 1;
+#elif defined (__fsu__)
+      msym = lookup_minimal_symbol (PTHREAD_KERN, NULL, NULL);
+      if (msym != NULL)
+        {
+          pthread_kern_addr = SYMBOL_VALUE_ADDRESS (msym);
+          thread_support = 1;
+        }
+#elif defined (HAVE_SPYTHREAD)
+      thread_support = libspy_enabled;
+#endif
+
+#ifdef I386_GNULINUX_TARGET
+      /* We support threads via the Linux Threads...  */
+      thread_support = 1;
+#endif
+
+      msym = lookup_minimal_symbol (KNOWN_TASKS_NAME, NULL, NULL);
+      if (msym != NULL)
+        known_tasks_addr = SYMBOL_VALUE_ADDRESS (msym);
+      else
+#ifndef VXWORKS_TARGET
+        return 0;
+#else
+        {
+          if (target_lookup_symbol (KNOWN_TASKS_NAME, &known_tasks_addr) != 0)
+            return 0;
+        }
+#endif
+
+      /* FIXME: brobecker 2003-03-05: Here would be a much better place
+         to attach the ada-tasks observers, instead of doing this
+         unconditionaly in _initialize_tasks. This would avoid an
+         unecessary notification when the inferior does not use tasking
+         or as long as the user does not use the ada-tasks commands.
+         Unfortunately, this is not possible for the moment: the current
+         code resets ada__tasks_check_symbol_table back to 1 whenever
+         symbols for a new program are being loaded. If we place the
+         observers intialization here, we will end up adding new observers
+         everytime we do the check for Ada tasking-related symbols
+         above. This would currently have benign effects, but is still
+         undesirable. The cleanest approach is probably to create a new
+         observer to notify us when the user is debugging a new program.
+         We would then reset ada__tasks_check_symbol_table back to 1
+         during the notification, but also detach all observers.
+         BTW: observers are probably not reentrant, so detaching during
+         a notification may not be the safest thing to do... Sigh...
+         But creating the new observer would be a good idea in any case,
+         since this allow us to make ada__tasks_check_symbol_table
+         static, which is a good bonus.  */
+      ada__tasks_check_symbol_table = 0;
+    }
+
+  return known_tasks_addr;
+}
+
+/* Read the Known_Tasks array from the inferior memory, and store
+   it in task_list.  Return non-zero upon success.  */
+
+static int
+read_known_tasks_array (void)
+{
+  const int target_ptr_byte = TARGET_PTR_BIT / TARGET_CHAR_BIT;
+  const int temp_tasks_size = target_ptr_byte * MAX_NUMBER_OF_KNOWN_TASKS;
+  const CORE_ADDR known_tasks_addr = get_known_tasks_addr ();
+  char *temp_tasks = (char *) alloca (temp_tasks_size);
+  CORE_ADDR temp_task;
+  int i;
+
+  /* Step 1: Clear the current list, if any.  */
+  init_task_list ();
+
+  /* If the application does not use task, then no more needs to be done.
+     It is important to have the task list cleared (see above) before we
+     return, as we don't want a stale task list to be used...  This can
+     happen for instance when debugging a non-multitasking program after
+     having debugged a multitasking one.  */
+  if (known_tasks_addr == 0)
+    return 0;
+
+  /* Step 2: Build a new list by reading the ATCBs from the Known_Tasks
+     array in the Ada runtime.  */
+  read_memory (known_tasks_addr, temp_tasks, temp_tasks_size);
+  for (i = 0; i < MAX_NUMBER_OF_KNOWN_TASKS; i++)
+    {
+      temp_task = extract_typed_address (temp_tasks + i * target_ptr_byte,
+					 builtin_type_void_data_ptr);
+
+      if (temp_task != 0)
+        {
+          if (get_entry_number (temp_task) == 0)
+            add_task_entry (temp_task, i);
+        }
+    }
+
+  /* Step 3: Unset stale_task_list_p, to avoid re-reading the Known_Tasks
+     array unless needed.  Then report a success.  */
+  stale_task_list_p = 0;
+  return 1;
+}
+
+/* Builds the task_list by reading the Known_Tasks array from
+   the inferior.  Prints an appropriate message and returns non-zero
+   if it failed to build this list.  */
+
+static int
+build_task_list (void)
+{
+  if (!target_has_stack)
+    error ("No stack");
+
+  if (stale_task_list_p)
+    read_known_tasks_array ();
+
+  if (task_list == NULL)
+    {
+      printf_filtered ("Your application does not use any Ada task.\n");
+      return 0;
+    }
+
+  return 1;
+}
+
+/* Extract the contents of the value as a string whose length is LENGTH,
+   and store the result in DEST.  */
+
+static void
+value_as_string (char *dest, struct value *val, int length)
+{
+  memcpy (dest, VALUE_CONTENTS (val), length);
+}
+
+/* Extract the string image from the fat string corresponding to VAL,
+   and store it in DEST. The length of the string is stored in LEN.  If
+   the string length is greater than MAX_LEN, then truncate the result
+   to the first MAX_LEN characters of the fat string.  */
+
+static void
+read_fat_string_value (char *dest, int *len, struct value *val, int max_len)
+{
+  struct value *array_val;
+  struct value *bounds_val;
+
+  /* The following variables are made static to avoid recomputing them
+     each time this function is called.  */
+  static int initialize_fieldnos = 1;
+  static int array_fieldno;
+  static int bounds_fieldno;
+  static int upper_bound_fieldno;
+
+  /* Get the index of the fields that we will need to read in order
+     to extract the string from the fat string.  */
+  if (initialize_fieldnos)
+    {
+      struct type *type = VALUE_TYPE (val);
+      struct type *bounds_type;
+
+      array_fieldno = ada_get_field_index (type, "P_ARRAY", 0);
+      bounds_fieldno = ada_get_field_index (type, "P_BOUNDS", 0);
+
+      bounds_type = TYPE_FIELD_TYPE (type, bounds_fieldno);
+      if (TYPE_CODE (bounds_type) == TYPE_CODE_PTR)
+        bounds_type = TYPE_TARGET_TYPE (bounds_type);
+      if (TYPE_CODE (bounds_type) != TYPE_CODE_STRUCT)
+        error ("Unknown task name format. Aborting");
+      upper_bound_fieldno = ada_get_field_index (bounds_type, "UB0", 0);
+
+      initialize_fieldnos = 0;
+    }
+
+  /* Get the size of the task image by checking the value of the bounds.
+     The lower bound is always 1, so we only need to read the upper bound.  */
+  bounds_val = value_ind (value_field (val, bounds_fieldno));
+  *len = value_as_long (value_field (bounds_val, upper_bound_fieldno));
+
+  /* Make sure that we do not read more than max_len characters...  */
+  if (*len > max_len)
+    *len = max_len;
+
+  /* Extract LEN characters from the fat string.  */
+  array_val = value_ind (value_field (val, array_fieldno));
+  read_memory (VALUE_ADDRESS (array_val), dest, *len);
+}
+
+/* Read the ATCB stored at ATCB_ADDR from the inferior memory.  */
+
+static struct task_control_block
+read_atcb (CORE_ADDR atcb_addr)
+{
+  /* The type description for the ATCB record and subrecords, and
+     the associated tcb_fieldnos. For efficiency reasons, these are made
+     static so that we can compute them only once the first time and
+     reuse them later.  */
+  static struct type *atcb_type = NULL;
+  static struct type *atcb_common_type = NULL;
+  static struct type *atcb_ll_type = NULL;
+  static struct tcb_fieldnos fieldno;
+
+  struct task_control_block result;
+  struct value *tcb_value;
+  struct value *ll_value;
+
+  if (atcb_type == NULL)
+    get_tcb_types_info (&atcb_type, &atcb_common_type, &atcb_ll_type, &fieldno);
+
+  tcb_value = value_from_contents_and_address (atcb_type, NULL, atcb_addr);
+  tcb_value = value_field (tcb_value, fieldno.common);
+
+  result.state = value_as_long (value_field (tcb_value, fieldno.state));
+  result.parent = value_as_address (value_field (tcb_value, fieldno.parent));
+  result.priority = value_as_long (value_field (tcb_value, fieldno.priority));
+
+  /* Depending on the GNAT version used, the task image is either a fat
+     string, or a thin array of characters.  Older versions of GNAT used
+     to use fat strings, and therefore did not need an extra field in
+     the ATCB to store the string length. For efficiency reasons, newer
+     versions of GNAT replaced the fat string by a static buffer, but this
+     also required the addition of a new field named "Image_Len" containing
+     the length of the task name. The method used to extract the task name
+     is selected depending on the existence of this field.  */
+  if (fieldno.image_len == -1)
+    {
+      read_fat_string_value (result.image, &result.image_len,
+                             value_field (tcb_value, fieldno.image),
+                             sizeof (result.image));
+    }
+  else
+    {
+      value_as_string (result.image, value_field (tcb_value, fieldno.image),
+                       sizeof (result.image));
+      result.image_len =
+        value_as_long (value_field (tcb_value, fieldno.image_len));
+    }
+
+  result.call = value_as_address (value_field (tcb_value, fieldno.call));
+
+  ll_value = value_field (tcb_value, fieldno.ll);
+  result.thread = value_as_address (value_field (ll_value, fieldno.ll_thread));
+  if (fieldno.ll_lwp >= 0)
+    result.lwp = value_as_address (value_field (ll_value, fieldno.ll_lwp));
+  else
+    result.lwp = 0;
+
+  return result;
+}
+
+/*  Read the ID of the task with which a task is attempting a rendez-vous
+    from the address of its Entry_Call_Record in the Ada TCB.
+    If the address of the Entry_Call_Record is null, then return null.  */
+
+static CORE_ADDR
+read_caller (const CORE_ADDR call)
+{
+  /* The type description for the Entry_Call_Record, and the index of
+     the field "Self".  For efficiency reasons, these are made static
+     so that we can compute them only once the first time and reuse them
+     later.  */
+  static struct type *atcb_call_type;
+  static int self_fieldno = -1;
+
+  struct value *call_value;
+
+  if (call == 0)
+    return 0;
+
+  if (atcb_call_type == NULL)
+    get_tcb_call_type_info (&atcb_call_type, &self_fieldno);
+
+  call_value = value_from_contents_and_address (atcb_call_type, NULL, call);
+  return value_as_address (value_field (call_value, self_fieldno));
+}
+
+#if 0
+/* FIXME: Now modified and back in breakpoint.c */
+/* breakpoint_task_match (PC) returns true if the breakpoint at PC
+   is valid for current task.  */
+
+int
+breakpoint_task_match (CORE_ADDR pc)
+{
+  const int this_task = get_current_task ();
+  const struct breakpoint *breakpoints = get_breakpoint_chain ();
+  const struct breakpoint *b;
+
+  for (b = breakpoints; b; b = b->next)
+    {
+      if (b->enable_state != bp_disabled
+          && b->enable_state != bp_shlib_disabled
+          && (b->address == 0 || b->address == pc)
+          && (b->task == 0 || b->task == this_task))
+        {
+          return 1;
+        }
+    }
+
+  return 0;
+}
+#endif
+
 /* Print detailed information about specified task */
 
 static void
 info_task (char *arg, int from_tty)
 {
-  void *temp_task;
+#ifdef GNAT_GDB
   struct task_entry *pt, *pt2;
-  void *self_id, *caller;
-  struct task_fields atcb, atcb2;
-  struct entry_call call;
-  int bounds[2];
-  char image[256];
+  CORE_ADDR caller;
   int num;
 
-  /* FIXME: language_ada should be defined in defs.h */
-  /*  if (current_language->la_language != language_ada) 
-     { 
-     printf_filtered ("The current language does not support tasks.\n"); 
-     return; 
-     } 
-   */
+  if (current_language->la_language != language_ada)
+    {
+      printf_filtered ("The current language does not support tasks.\n");
+      return;
+    }
+
+  target_find_new_threads ();
+
   pt = get_entry_vptr (atoi (arg));
   if (pt == NULL)
     {
@@ -310,59 +1069,44 @@ info_task (char *arg, int from_tty)
       return;
     }
 
-  temp_task = pt->task_id;
-
-  /* read the atcb in the inferior */
-  READ_MEMORY ((CORE_ADDR) temp_task, atcb);
-
   /* print the Ada task id */
-  printf_filtered ("Ada Task: %p\n", temp_task);
+  printf_filtered ("Ada Task: %s\n", paddr_nz (pt->task_id));
 
   /* print the name of the task */
-  if (atcb.image.P_ARRAY != NULL)
-    {
-      READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_BOUNDS), bounds);
-      bounds[1] = EXTRACT_INT (bounds[1]);
-      read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_ARRAY),
-		   (char *) &image, bounds[1]);
-      printf_filtered ("Name: %.*s\n", bounds[1], image);
-    }
+  if (pt->atcb.image_len != 0)
+    printf_filtered ("Name: %.*s\n", pt->atcb.image_len, pt->atcb.image);
   else
     printf_filtered ("<no name>\n");
 
   /* print the thread id */
 
-  if ((long) pt->thread < 65536)
-    printf_filtered ("Thread: %ld\n", (long int) pt->thread);
+  if (task_ptid_get_tid (pt->task_ptid) < 65536)
+    printf_filtered
+      ("Thread: %ld\n", (long int) task_ptid_get_tid (pt->task_ptid));
   else
-    printf_filtered ("Thread: %p\n", pt->thread);
+    printf_filtered
+      ("Thread: %#lx\n", (long int) task_ptid_get_tid (pt->task_ptid));
 
-  if ((long) pt->lwp != 0)
+  if (task_ptid_get_lwp (pt->task_ptid) != 0)
     {
-      if ((long) pt->lwp < 65536)
-	printf_filtered ("LWP: %ld\n", (long int) pt->lwp);
+      if ((long) task_ptid_get_lwp (pt->task_ptid) < 65536)
+        printf_filtered
+          ("LWP: %ld\n", (long int) task_ptid_get_lwp (pt->task_ptid));
       else
-	printf_filtered ("LWP: %p\n", pt->lwp);
+        printf_filtered
+          ("LWP: %#lx\n", (long int) task_ptid_get_lwp (pt->task_ptid));
     }
 
   /* print the parent gdb task id */
-  num = get_entry_number (EXTRACT_ADDRESS (atcb.parent));
+  num = get_entry_number (pt->atcb.parent);
   if (num != 0)
     {
       printf_filtered ("Parent: %d", num);
       pt2 = get_entry_vptr (num);
-      READ_MEMORY ((CORE_ADDR) pt2->task_id, atcb2);
 
       /* print the name of the task */
-      if (atcb2.image.P_ARRAY != NULL)
-	{
-	  READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_BOUNDS),
-		       bounds);
-	  bounds[1] = EXTRACT_INT (bounds[1]);
-	  read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_ARRAY),
-		       (char *) &image, bounds[1]);
-	  printf_filtered (" (%.*s)\n", bounds[1], image);
-	}
+      if (pt2->atcb.image_len != 0)
+	printf_filtered (" (%.*s)\n", pt2->atcb.image_len, pt2->atcb.image);
       else
 	printf_filtered ("\n");
     }
@@ -370,20 +1114,13 @@ info_task (char *arg, int from_tty)
     printf_filtered ("No parent\n");
 
   /* print the base priority of the task */
-  printf_filtered ("Base Priority: %d\n", EXTRACT_INT (atcb.priority));
+  printf_filtered ("Base Priority: %d\n", pt->atcb.priority);
 
   /* print the current state of the task */
 
   /* check if this task is accepting a rendezvous */
-  if (atcb.call == NULL)
-    caller = NULL;
-  else
-    {
-      READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.call), call);
-      caller = EXTRACT_ADDRESS (call.self);
-    }
-
-  if (caller != NULL)
+  caller = read_caller (pt->atcb.call);
+  if (caller != 0)
     {
       num = get_entry_number (caller);
       printf_filtered ("Accepting rendezvous with %d", num);
@@ -391,164 +1128,46 @@ info_task (char *arg, int from_tty)
       if (num != 0)
 	{
 	  pt2 = get_entry_vptr (num);
-	  READ_MEMORY ((CORE_ADDR) pt2->task_id, atcb2);
 
 	  /* print the name of the task */
-	  if (atcb2.image.P_ARRAY != NULL)
-	    {
-	      READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_BOUNDS),
-			   bounds);
-	      bounds[1] = EXTRACT_INT (bounds[1]);
-	      read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb2.image.P_ARRAY),
-			   (char *) &image, bounds[1]);
-	      printf_filtered (" (%.*s)\n", bounds[1], image);
-	    }
+	  if (pt2->atcb.image_len != 0) {
+	    printf_filtered (" (%.*s)\n", pt2->atcb.image_len, pt2->atcb.image);
+	  }
 	  else
 	    printf_filtered ("\n");
 	}
       else
-	printf_filtered ("\n");
+        printf_filtered ("\n");
     }
   else
-    printf_filtered ("State: %s\n", ada_long_task_states[atcb.state]);
-}
-
-#if 0
-
-/* A useful function that shows the alignment of all the fields in the
-   tasks_fields structure
- */
-
-print_align (void)
-{
-  struct task_fields tf;
-  void *tf_base = &(tf);
-  void *tf_state = &(tf.state);
-  void *tf_entry_num = &(tf.entry_num);
-  void *tf_parent = &(tf.parent);
-  void *tf_priority = &(tf.priority);
-  void *tf_current_priority = &(tf.current_priority);
-  void *tf_image = &(tf.image);
-  void *tf_call = &(tf.call);
-  void *tf_thread = &(tf.thread);
-  void *tf_lwp = &(tf.lwp);
-  printf_filtered ("\n");
-  printf_filtered ("(tf_base = 0x%x)\n", tf_base);
-  printf_filtered ("task_fields.entry_num        at %3d (0x%x)\n",
-		   tf_entry_num - tf_base, tf_entry_num);
-  printf_filtered ("task_fields.state            at %3d (0x%x)\n",
-		   tf_state - tf_base, tf_state);
-  printf_filtered ("task_fields.parent           at %3d (0x%x)\n",
-		   tf_parent - tf_base, tf_parent);
-  printf_filtered ("task_fields.priority         at %3d (0x%x)\n",
-		   tf_priority - tf_base, tf_priority);
-  printf_filtered ("task_fields.current_priority at %3d (0x%x)\n",
-		   tf_current_priority - tf_base, tf_current_priority);
-  printf_filtered ("task_fields.image            at %3d (0x%x)\n",
-		   tf_image - tf_base, tf_image);
-  printf_filtered ("task_fields.call             at %3d (0x%x)\n",
-		   tf_call - tf_base, tf_call);
-  printf_filtered ("task_fields.thread           at %3d (0x%x)\n",
-		   tf_thread - tf_base, tf_thread);
-  printf_filtered ("task_fields.lwp              at %3d (0x%x)\n",
-		   tf_lwp - tf_base, tf_lwp);
-  printf_filtered ("\n");
-}
+    printf_filtered ("State: %s\n", long_task_states[pt->atcb.state]);
 #endif
+}
 
 /* Print information about currently known tasks */
 
 static void
 info_tasks (char *arg, int from_tty)
 {
-  struct value *val;
-  int i, task_number, state;
-  void *temp_task, *temp_tasks[MAX_NUMBER_OF_KNOWN_TASKS];
+#ifdef GNAT_GDB
   struct task_entry *pt;
-  void *self_id, *caller, *thread_id = NULL;
-  struct task_fields atcb;
-  struct entry_call call;
-  int bounds[2];
-  char image[256];
+  CORE_ADDR caller;
+  long thread_id = 0L;
   int size;
   char car;
+  ptid_t current_ptid;
 
 #if defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET)
   pthreadTeb_t thr;
   gdb_gregset_t regs;
 #endif
 
-  static struct symbol *sym;
-  static struct minimal_symbol *msym;
-  static void *known_tasks_addr = NULL;
-
-  int init_only = gdbtk_task_initialization;
-  gdbtk_task_initialization = 0;
-
-  task_number = 0;
-
-  if (PIDGET (inferior_ptid) == 0)
-    {
-      printf_filtered ("The program is not being run under gdb. ");
-      printf_filtered ("Use 'run' or 'attach' first.\n");
-      return;
-    }
-
-  if (ada__tasks_check_symbol_table)
-    {
-      thread_support = 0;
-#if (defined(__alpha__) && defined(__osf__) & !defined(VXWORKS_TARGET)) || \
-    defined (_AIX)
-      thread_support = 1;
-#endif
-
-      msym = lookup_minimal_symbol (KNOWN_TASKS_NAME, NULL, NULL);
-      if (msym != NULL)
-	known_tasks_addr = (void *) SYMBOL_VALUE_ADDRESS (msym);
-      else
-#ifndef VXWORKS_TARGET
-	return;
-#else
-	{
-	  if (target_lookup_symbol (KNOWN_TASKS_NAME, &known_tasks_addr) != 0)
-	    return;
-	}
-#endif
-
-      ada__tasks_check_symbol_table = 0;
-    }
-
-  if (known_tasks_addr == NULL)
-    return;
+  current_ptid = inferior_ptid;
 
 #if !((defined(sun) && defined(__SVR4)) || defined(VXWORKS_TARGET) || defined(__WIN32__) || defined (hpux))
   if (thread_support)
 #endif
-    thread_id = GET_CURRENT_THREAD ();
-
-  /* then we get a list of tasks created */
-
-  init_task_list ();
-
-  READ_MEMORY ((CORE_ADDR) known_tasks_addr, temp_tasks);
-
-  for (i = 0; i < MAX_NUMBER_OF_KNOWN_TASKS; i++)
-    {
-      temp_task = EXTRACT_ADDRESS (temp_tasks[i]);
-
-      if (temp_task != NULL)
-	{
-	  task_number = get_entry_number (temp_task);
-	  if (task_number == 0)
-	    task_number = add_task_entry (temp_task, i);
-	}
-    }
-
-  /* Return without printing anything if this function was called in
-     order to init GDBTK tasking. */
-
-  if (init_only)
-    return;
+    thread_id = GET_CURRENT_THREAD (inferior_ptid);
 
   /* print the header */
 
@@ -563,255 +1182,301 @@ info_tasks (char *arg, int from_tty)
   pt = task_list;
   while (pt)
     {
-      temp_task = pt->task_id;
-
-      /* read the atcb in the inferior */
-      READ_MEMORY ((CORE_ADDR) temp_task, atcb);
-
-      /* store the thread id for future use */
-      pt->thread = EXTRACT_ADDRESS (atcb.thread);
-
-#if defined (linux)
-      pt->lwp = (void *) THREAD_TO_PID (atcb.thread, 0);
-#else
-      pt->lwp = EXTRACT_ADDRESS (atcb.lwp);
-#endif
-
       /* print a star if this task is the current one */
       if (thread_id)
 #if defined (__WIN32__) || defined (SGI) || defined (hpux)
-	printf_filtered (pt->lwp == thread_id ? "*" : " ");
+        printf_filtered
+          (task_ptid_get_lwp (pt->task_ptid) == thread_id ? "*" : " ");
 #else
-	printf_filtered (pt->thread == thread_id ? "*" : " ");
+        printf_filtered
+          (task_ptid_get_thread_id (pt->task_ptid) == thread_id ? "*" : " ");
 #endif
 
       /* print the gdb task id */
       printf_filtered ("%3d", pt->task_num);
 
       /* print the Ada task id */
-#ifndef VXWORKS_TARGET
-      printf_filtered (" %9lx", (long) temp_task);
-#else
-#ifdef TARGET_64
-      printf_filtered (" %#9lx", (unsigned long) pt->thread & 0x3ffffffffff);
-#else
-      printf_filtered (" %#9lx", (long) pt->thread);
-#endif
-#endif
+      printf_filtered (" %9lx", (long) pt->task_id);
 
       /* print the parent gdb task id */
-      printf_filtered
-	(" %4d", get_entry_number (EXTRACT_ADDRESS (atcb.parent)));
+      printf_filtered (" %4d", get_entry_number (pt->atcb.parent));
 
       /* print the base priority of the task */
-      printf_filtered (" %3d", EXTRACT_INT (atcb.priority));
+      printf_filtered (" %3d", pt->atcb.priority);
 
 #if defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET)
-      if (pt->task_num == 1 || atcb.state == Terminated)
-	{
-	  printf_filtered ("  Unknown");
-	  goto next;
-	}
-
-      read_memory ((CORE_ADDR) atcb.thread, &thr, sizeof (thr));
-      current_thread = atcb.thread;
+      if (pt->task_num == 1 || pt->atcb.state == Terminated)
+        {
+          printf_filtered ("  Unknown");
+          goto next;
+        }
+
+      READ_MEMORY (pt->atcb.thread, thr);
+      switch_to_thread (task_ptid_get_ptid (pt->task_ptid));
+      /* ??? Brobecker 2003-03-13: Not sure what the next line is used for.
+         And even if useful, it should probably be replaced by call to
+         task_ptid_get_thread_id.  */
+      current_thread = task_ptid_get_tid (pt->task_ptid);
       regs.regs[SP_REGNUM] = 0;
       if (dec_thread_get_registers (&regs, NULL) == 0)
-	{
-	  pt->stack_per = (100 * ((long) thr.__stack_base -
-				  regs.regs[SP_REGNUM])) / thr.__stack_size;
-	  /* if the thread is terminated but still there, the
-	     stack_base/size values are erroneous. Try to patch it */
-	  if (pt->stack_per < 0 || pt->stack_per > 100)
-	    pt->stack_per = 0;
-	}
+        {
+          pt->stack_per = (100 * ((long) thr.__stack_base -
+                                  regs.regs[SP_REGNUM])) / thr.__stack_size;
+          /* if the thread is terminated but still there, the
+             stack_base/size values are erroneous. Try to patch it */
+          if (pt->stack_per < 0 || pt->stack_per > 100)
+            pt->stack_per = 0;
+        }
+      else
+        {
+          /* Set stack_per to an invalid value to signal that we did not
+             manage to compute its value.  */
+          pt->stack_per = -1;
+        }
 
       /* print information about stack space used in the thread */
       if (thr.__stack_size < 1024 * 1024)
-	{
-	  size = thr.__stack_size / 1024;
-	  car = 'K';
-	}
+        {
+          size = thr.__stack_size / 1024;
+          car = 'K';
+        }
       else if (thr.__stack_size < 1024 * 1024 * 1024)
-	{
-	  size = thr.__stack_size / 1024 / 1024;
-	  car = 'M';
-	}
-      else			/* Who knows... */
-	{
-	  size = thr.__stack_size / 1024 / 1024 / 1024;
-	  car = 'G';
-	}
-      printf_filtered (" %4d%c %2d", size, car, pt->stack_per);
+        {
+          size = thr.__stack_size / 1024 / 1024;
+          car = 'M';
+        }
+      else                      /* Who knows... */
+        {
+          size = thr.__stack_size / 1024 / 1024 / 1024;
+          car = 'G';
+        }
+
+      /* print the stack usage in percent, if available.  */
+      if (pt->stack_per != -1)
+        printf_filtered (" %4d%c %2d", size, car, pt->stack_per);
+      else
+        {
+          /* This error is not serious enough that we should raise
+             an internal error, but print '???' to make it unambiguous
+             that we failed to compute this value.  */
+          printf_filtered (" ???");
+        }
+
     next:
 #endif
 
       /* print the current state of the task */
 
       /* check if this task is accepting a rendezvous */
-      if (atcb.call == NULL)
-	caller = NULL;
-      else
-	{
-	  READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.call), call);
-	  caller = EXTRACT_ADDRESS (call.self);
-	}
-
-      if (caller != NULL)
-	printf_filtered (" Accepting RV with %-4d",
-			 get_entry_number (caller));
+      caller = read_caller (pt->atcb.call);
+      if (caller != 0)
+        printf_filtered (" Accepting RV with %-4d",
+                         get_entry_number (caller));
       else
-	{
-	  state = atcb.state;
+        {
 #if defined (__WIN32__) || defined (SGI) || defined (hpux)
-	  if (state == Runnable && (thread_id && pt->lwp == thread_id))
+          if (pt->atcb.state == Runnable
+              && (thread_id
+                  && task_ptid_get_lwp (pt->task_ptid) == thread_id))
 #else
-	  if (state == Runnable && (thread_id && pt->thread == thread_id))
-#endif
-	    /* Replace "Runnable" by "Running" if this is the current task */
-	    printf_filtered (" %-22s", "Running");
-	  else
-	    printf_filtered (" %-22s", ada_task_states[state]);
-	}
+          if (pt->atcb.state == Runnable
+              && (thread_id
+                  && task_ptid_get_thread_id (pt->task_ptid) == thread_id))
+#endif
+            /* Replace "Runnable" by "Running" if this is the current task */
+            printf_filtered (" %-22s", "Running");
+          else
+            printf_filtered (" %-22s", task_states[pt->atcb.state]);
+        }
 
       /* finally, print the name of the task */
-      if (atcb.image.P_ARRAY != NULL)
-	{
-	  READ_MEMORY ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_BOUNDS),
-		       bounds);
-	  bounds[1] = EXTRACT_INT (bounds[1]);
-	  read_memory ((CORE_ADDR) EXTRACT_ADDRESS (atcb.image.P_ARRAY),
-		       (char *) &image, bounds[1]);
-	  printf_filtered (" %.*s\n", bounds[1], image);
-	}
+      if (pt->atcb.image_len != 0) {
+        printf_filtered (" %.*s\n", pt->atcb.image_len, pt->atcb.image);
+      }
       else
 	printf_filtered (" <no name>\n");
 
       pt = pt->next_task;
     }
-}
-
-/* Task list initialization for GDB-Tk.  We basically use info_tasks()
-   to initialize our variables, but abort that function before we
-   actually print anything. */
-
-int
-gdbtk_tcl_tasks_initialize (void)
-{
-  gdbtk_task_initialization = 1;
-  info_tasks ("", gdb_stdout);
-
-  return (task_list != NULL);
+  if (!ptid_equal (inferior_ptid, current_ptid))
+    switch_to_thread (current_ptid);
+#endif
 }
 
 static void
 info_tasks_command (char *arg, int from_tty)
 {
+  const int task_list_built = build_task_list ();
+
+  if (!task_list_built)
+    return;
+
   if (arg == NULL || *arg == '\000')
     info_tasks (arg, from_tty);
   else
     info_task (arg, from_tty);
 }
 
-/* Switch from one thread to another. */
+/* Switch to task indicated by NEW_TASK.  Return 0 iff successful.  */
 
-static void
-switch_to_thread (ptid_t ptid)
+static int
+switch_to_task (struct task_entry *new_task)
 {
-  if (ptid_equal (ptid, inferior_ptid))
-    return;
-
-  inferior_ptid = ptid;
-  flush_cached_frames ();
-  registers_changed ();
-  stop_pc = read_pc ();
-  select_frame (get_current_frame ());
-}
+#ifdef GNAT_GDB
+  /* Raise an error if task-switching is currently not allowed.  */
+  if (!THREAD_SWITCH_ALLOWED ())
+    error ("Task switching is currently not allowed.");
+
+  if (!task_is_alive (new_task->atcb.state))
+    error ("Can not switch to task %d: Task is no longer running",
+           new_task->task_num);
 
-/* Switch to a specified task. */
+  current_task = new_task->task_num;
+  current_thread = task_ptid_get_thread_id (new_task->task_ptid);
 
-static int
-task_switch (void *tid, void *lwpid)
-{
-  int res = 0, pid;
+  if (current_task_id == -1)
+    {
+      SAVE_TASK_REGISTERS (new_task);
+      current_task_id = ada_get_current_task (inferior_ptid);
+    }
 
-  if (thread_support)
+  if (SPECIAL_THREAD_SUPPORT_ACTIVE ())
     {
+      /* FIXME: Integrate with switch_to_thread */
+      int ret_code;
       flush_cached_frames ();
-
-      if (current_task != current_task_id)
-	{
-	  res = THREAD_FETCH_REGISTERS ();
-	}
+      registers_changed ();
+      if (current_task == current_task_id)
+        {
+          RESTORE_TASK_REGISTERS (new_task);
+          ret_code = 0;
+        }
       else
-	{
-#if (defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET))
-	  supply_gregset (&gregset_saved);
-	  supply_fpregset (&fpregset_saved);
-#endif
-	}
-
-      if (res == 0)
-	stop_pc = read_pc ();
+        ret_code = THREAD_FETCH_REGISTERS ();
+      if (ret_code == 0)
+        stop_pc = read_pc ();
       select_frame (get_current_frame ());
-      return res;
+      return ret_code;
     }
-
+  else if (task_ptid_get_pid (new_task->task_ptid) != 0)        /* ?? */
+    {
+      switch_to_thread (task_ptid_get_ptid (new_task->task_ptid));
+      return 0;
+    }
+#endif
   return -1;
 }
 
+/* Print a message telling the user id of the current task.
+   Print an error message if the application does not appear to
+   be using any Ada task.  */
+
 static void
-task_command (char *tidstr, int from_tty)
+display_current_task_id (void) 
 {
-  int num;
-  struct task_entry *e;
+  const int current_task = ada_get_current_task (inferior_ptid);
+
+  if (current_task == -1)
+    printf_filtered ("[Current task is unknown]\n");
+  else
+    printf_filtered ("[Current task is %d]\n", current_task);
+}
 
-  if (!tidstr)
-    error ("Please specify a task ID.  Use the \"info tasks\" command to\n"
-	   "see the IDs of currently known tasks.");
+/* Parse and evaluate TIDSTR into a task id, and try to switch to
+   that task.  Print an error message if the task switch failed.  */
 
-  num = atoi (tidstr);
-  e = get_entry_vptr (num);
+static void
+task_command_1 (char *tidstr, int from_tty)
+{
+  const int num = value_as_long (parse_and_eval (tidstr));
+  struct task_entry *e = get_entry_vptr (num);
 
   if (e == NULL)
     error ("Task ID %d not known.  Use the \"info tasks\" command to\n"
-	   "see the IDs of currently known tasks.", num);
-
-  if (current_task_id == -1)
-    {
-#if (defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET))
-      fill_gregset (&gregset_saved, -1);
-      fill_fpregset (&fpregset_saved, -1);
-#endif
-      current_task_id = get_current_task ();
-    }
+           "see the IDs of currently known tasks", num);
 
-  current_task = num;
-  current_task_index = e->known_tasks_index;
-  current_thread = e->thread;
-  current_lwp = e->lwp;
-  if (task_switch (e->thread, e->lwp) == 0)
+  if (switch_to_task (e) == 0)
     {
-      /* FIXME: find_printable_frame should be defined in frame.h, and
-         implemented in ada-lang.c */
+      ada_find_printable_frame (get_selected_frame ());
       printf_filtered ("[Switching to task %d]\n", num);
-      print_stack_frame (get_selected_frame (), 1, SRC_AND_LOC);
+      print_stack_frame (get_selected_frame (),
+                         frame_relative_level (get_selected_frame ()), 1);
     }
   else
     printf_filtered ("Unable to switch to task %d\n", num);
 }
 
+/* Switch to task indicated in TIDSTR.  Simply print the current task
+   if TIDSTR is empty or NULL.  */
+
+static void
+task_command (char *tidstr, int from_tty)
+{
+  const int task_list_built = build_task_list ();
+
+  if (!task_list_built)
+    return;
+
+  if (tidstr == NULL || tidstr[0] == '\0')
+    display_current_task_id ();
+  else
+    task_command_1 (tidstr, from_tty);
+}
+
+#if defined (__fsu__) || (defined(__alpha__) && defined(__osf__) && !defined(VXWORKS_TARGET))
+/* Restore saved registers if there was a task switch.  */
+void
+ada_reset_thread_registers (void)
+{
+  if (current_task_id != -1 && SPECIAL_THREAD_SUPPORT_ACTIVE ())
+    {
+      supply_gregset (&gregset_saved);
+      supply_fpregset (&fpregset_saved);
+      reinit_frame_cache ();
+      stop_pc = read_pc ();
+    }
+  current_task_id = -1;
+}
+#else
+void
+ada_reset_thread_registers (void)
+{
+}
+#endif
+
+/* The 'normal_stop' observer notification callback.  */
+
+static void
+normal_stop_notification (void)
+{
+  /* The inferior has been resumed, and just stopped. This means that
+     our task_list needs to be recomputed before it can be used again.  */
+  stale_task_list_p = 1;
+}
+
+/* Attach all the observers needed by the ada-tasks module.  */
+
+static void
+ada_tasks_attach_observers (void)
+{
+  observer_attach_normal_stop (&normal_stop_notification);
+}
+
 void
 _initialize_tasks (void)
 {
-  static struct cmd_list_element *task_cmd_list = NULL;
+#ifdef GNAT_GDB
   extern struct cmd_list_element *cmdlist;
 
+  ada_tasks_attach_observers ();
+
   add_info ("tasks", info_tasks_command,
-	    "Without argument: list all known Ada tasks, with status information.\n"
-	    "info tasks n: print detailed information of task n.\n");
+            "Without argument: list all known Ada tasks, with status information.\n"
+            "info tasks n: print detailed information of task n.");
 
-  add_prefix_cmd ("task", class_run, task_command,
-		  "Use this command to switch between tasks.\n\
- The new task ID must be currently known.", &task_cmd_list, "task ", 1, &cmdlist);
+  add_cmd ("task", class_run, task_command,
+           "Without argument: print the current task ID.\n"
+           "task n: Use this command to switch to task n.",
+           &cmdlist);
+#endif
 }
Index: gdb/ada-typeprint.c
===================================================================
RCS file: /cvs/src/src/gdb/ada-typeprint.c,v
retrieving revision 1.6
diff -u -p -r1.6 ada-typeprint.c
--- gdb/ada-typeprint.c	20 Feb 2003 17:17:23 -0000	1.6
+++ gdb/ada-typeprint.c	2 Jun 2004 09:52:56 -0000
@@ -1,6 +1,6 @@
 /* Support for printing Ada types for GDB, the GNU debugger.
-   Copyright 1986, 1988, 1989, 1991, 1997, 2003 Free Software
-   Foundation, Inc.
+   Copyright 1986, 1988, 1989, 1991, 1997, 1998, 1999, 2000, 
+   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
 
 This file is part of GDB.
 
@@ -63,11 +63,11 @@ static void print_range_type_named (char
 static char *name_buffer;
 static int name_buffer_len;
 
-/* The (demangled) Ada name of TYPE. This value persists until the
-   next call. */
+/* The (decoded) Ada name of TYPE.  This value persists until the
+   next call.  */
 
 static char *
-demangled_type_name (struct type *type)
+decoded_type_name (struct type *type)
 {
   if (ada_type_name (type) == NULL)
     return NULL;
@@ -116,9 +116,9 @@ demangled_type_name (struct type *type)
 }
 
 
-/* Print a description of a type in the format of a 
+/* Print a description of a type in the format of a
    typedef for the current language.
-   NEW is the new name for a type TYPE. */
+   NEW is the new name for a type TYPE.  */
 
 void
 ada_typedef_print (struct type *type, struct symbol *new,
@@ -130,7 +130,7 @@ ada_typedef_print (struct type *type, st
   type_print (type, "", stream, 1);
 }
 
-/* Print range type TYPE on STREAM. */
+/* Print range type TYPE on STREAM.  */
 
 static void
 print_range (struct type *type, struct ui_file *stream)
@@ -155,9 +155,9 @@ print_range (struct type *type, struct u
 
   if (TYPE_NFIELDS (type) < 2)
     {
-      /* A range needs at least 2 bounds to be printed. If there are less
+      /* A range needs at least 2 bounds to be printed.  If there are less
          than 2, just print the type name instead of the range itself.
-         This check handles cases such as characters, for example. 
+         This check handles cases such as characters, for example.
 
          Note that if the name is not defined, then we don't print anything.
        */
@@ -180,7 +180,7 @@ print_range (struct type *type, struct u
 }
 
 /* Print the number or discriminant bound at BOUNDS+*N on STREAM, and
-   set *N past the bound and its delimiter, if any. */
+   set *N past the bound and its delimiter, if any.  */
 
 static void
 print_range_bound (struct type *type, char *bounds, int *n,
@@ -189,6 +189,19 @@ print_range_bound (struct type *type, ch
   LONGEST B;
   if (ada_scan_number (bounds, *n, &B, n))
     {
+      /* STABS decodes all range types which bounds are 0 .. -1 as
+         unsigned integers (ie. the type code is TYPE_CODE_INT, not
+         TYPE_CODE_RANGE).  Unfortunately, ada_print_scalar() relies
+         on the unsigned flag to determine whether the bound should
+         be printed as a signed or an unsigned value.  This causes
+         the upper bound of the 0 .. -1 range types to be printed as
+         a very large unsigned number instead of -1.
+         To workaround this stabs deficiency, we replace the TYPE by
+         builtin_type_long when we detect that the bound is negative,
+         and the type is a TYPE_CODE_INT.  The bound is negative when
+         'm' is the last character of the number scanned in BOUNDS.  */
+      if (bounds[*n - 1] == 'm' && TYPE_CODE (type) == TYPE_CODE_INT)
+	type = builtin_type_long;
       ada_print_scalar (type, B, stream);
       if (bounds[*n] == '_')
 	*n += 2;
@@ -213,7 +226,7 @@ print_range_bound (struct type *type, ch
 
 /* Assuming NAME[0 .. NAME_LEN-1] is the name of a range type, print
    the value (if found) of the bound indicated by SUFFIX ("___L" or
-   "___U") according to the ___XD conventions. */
+   "___U") according to the ___XD conventions.  */
 
 static void
 print_dynamic_range_bound (struct type *type, const char *name, int name_len,
@@ -228,21 +241,20 @@ print_dynamic_range_bound (struct type *
   strncpy (name_buf, name, name_len);
   strcpy (name_buf + name_len, suffix);
 
-  B = get_int_var_value (name_buf, 0, &OK);
+  B = get_int_var_value (name_buf, &OK);
   if (OK)
     ada_print_scalar (type, B, stream);
   else
     fprintf_filtered (stream, "?");
 }
 
-/* Print the range type named NAME. */
+/* Print the range type named NAME.  */
 
 static void
 print_range_type_named (char *name, struct ui_file *stream)
 {
   struct type *raw_type = ada_find_any_type (name);
   struct type *base_type;
-  LONGEST low, high;
   char *subtype_info;
 
   if (raw_type == NULL)
@@ -269,24 +281,24 @@ print_range_type_named (char *name, stru
 
       if (*subtype_info == 'L')
 	{
-	  print_range_bound (raw_type, bounds_str, &n, stream);
+	  print_range_bound (base_type, bounds_str, &n, stream);
 	  subtype_info += 1;
 	}
       else
-	print_dynamic_range_bound (raw_type, name, prefix_len, "___L",
+	print_dynamic_range_bound (base_type, name, prefix_len, "___L",
 				   stream);
 
       fprintf_filtered (stream, " .. ");
 
       if (*subtype_info == 'U')
-	print_range_bound (raw_type, bounds_str, &n, stream);
+	print_range_bound (base_type, bounds_str, &n, stream);
       else
-	print_dynamic_range_bound (raw_type, name, prefix_len, "___U",
+	print_dynamic_range_bound (base_type, name, prefix_len, "___U",
 				   stream);
     }
 }
 
-/* Print enumerated type TYPE on STREAM. */
+/* Print enumerated type TYPE on STREAM.  */
 
 static void
 print_enum_type (struct type *type, struct ui_file *stream)
@@ -315,7 +327,7 @@ print_enum_type (struct type *type, stru
   fprintf_filtered (stream, ")");
 }
 
-/* Print representation of Ada fixed-point type TYPE on STREAM. */
+/* Print representation of Ada fixed-point type TYPE on STREAM.  */
 
 static void
 print_fixed_point_type (struct type *type, struct ui_file *stream)
@@ -333,7 +345,7 @@ print_fixed_point_type (struct type *typ
     }
 }
 
-/* Print representation of special VAX floating-point type TYPE on STREAM. */
+/* Print representation of special VAX floating-point type TYPE on STREAM.  */
 
 static void
 print_vax_floating_point_type (struct type *type, struct ui_file *stream)
@@ -342,10 +354,10 @@ print_vax_floating_point_type (struct ty
 		    ada_vax_float_type_suffix (type));
 }
 
-/* Print simple (constrained) array type TYPE on STREAM.  LEVEL is the 
-   recursion (indentation) level, in case the element type itself has 
+/* Print simple (constrained) array type TYPE on STREAM.  LEVEL is the
+   recursion (indentation) level, in case the element type itself has
    nested structure, and SHOW is the number of levels of internal
-   structure to show (see ada_print_type). */
+   structure to show (see ada_print_type).  */
 
 static void
 print_array_type (struct type *type, struct ui_file *stream, int show,
@@ -364,7 +376,12 @@ print_array_type (struct type *type, str
     {
       if (ada_is_packed_array_type (type))
 	type = ada_coerce_to_simple_array_type (type);
-      if (ada_is_simple_array (type))
+      if (type == NULL)
+        {
+          fprintf_filtered (stream, "<undecipherable array type>");
+          return;
+        }
+      if (ada_is_simple_array_type (type))
 	{
 	  struct type *range_desc_type =
 	    ada_find_parallel_type (type, "___XA");
@@ -417,7 +434,7 @@ print_array_type (struct type *type, str
 }
 
 /* Print the choices encoded by field FIELD_NUM of variant-part TYPE on
-   STREAM, assuming the VAL_TYPE is the type of the values. */
+   STREAM, assuming the VAL_TYPE is the type of the values.  */
 
 static void
 print_choices (struct type *type, int field_num, struct ui_file *stream,
@@ -429,7 +446,7 @@ print_choices (struct type *type, int fi
 
   have_output = 0;
 
-  /* Skip over leading 'V': NOTE soon to be obsolete. */
+  /* Skip over leading 'V': NOTE soon to be obsolete.  */
   if (name[0] == 'V')
     {
       if (!ada_scan_number (name, 1, NULL, &p))
@@ -486,14 +503,14 @@ Huh:
 
 }
 
-/* Assuming that field FIELD_NUM of TYPE is a VARIANTS field whose 
-   discriminant is contained in OUTER_TYPE, print its variants on STREAM.  
+/* Assuming that field FIELD_NUM of TYPE is a VARIANTS field whose
+   discriminant is contained in OUTER_TYPE, print its variants on STREAM.
    LEVEL is the recursion
    (indentation) level, in case any of the fields themselves have
    nested structure, and SHOW is the number of levels of internal structure
-   to show (see ada_print_type). For this purpose, fields nested in a
+   to show (see ada_print_type).  For this purpose, fields nested in a
    variant part are taken to be at the same level as the fields
-   immediately outside the variant part. */
+   immediately outside the variant part.  */
 
 static void
 print_variant_clauses (struct type *type, int field_num,
@@ -501,7 +518,7 @@ print_variant_clauses (struct type *type
 		       int show, int level)
 {
   int i;
-  struct type *var_type;
+  struct type *var_type, *par_type;
   struct type *discr_type;
 
   var_type = TYPE_FIELD_TYPE (type, field_num);
@@ -510,14 +527,14 @@ print_variant_clauses (struct type *type
   if (TYPE_CODE (var_type) == TYPE_CODE_PTR)
     {
       var_type = TYPE_TARGET_TYPE (var_type);
-      if (TYPE_FLAGS (var_type) & TYPE_FLAG_STUB)
-	{
-	  var_type = ada_find_parallel_type (var_type, "___XVU");
-	  if (var_type == NULL)
-	    return;
-	}
+      if (var_type == NULL || TYPE_CODE (var_type) != TYPE_CODE_UNION)
+	return;
     }
 
+  par_type = ada_find_parallel_type (var_type, "___XVU");
+  if (par_type != NULL)
+    var_type = par_type;
+
   for (i = 0; i < TYPE_NFIELDS (var_type); i += 1)
     {
       fprintf_filtered (stream, "\n%*swhen ", level + 4, "");
@@ -529,13 +546,13 @@ print_variant_clauses (struct type *type
     }
 }
 
-/* Assuming that field FIELD_NUM of TYPE is a variant part whose 
+/* Assuming that field FIELD_NUM of TYPE is a variant part whose
    discriminants are contained in OUTER_TYPE, print a description of it
-   on STREAM.  LEVEL is the recursion (indentation) level, in case any of 
-   the fields themselves have nested structure, and SHOW is the number of 
-   levels of internal structure to show (see ada_print_type). For this 
-   purpose, fields nested in a variant part are taken to be at the same 
-   level as the fields immediately outside the variant part. */
+   on STREAM.  LEVEL is the recursion (indentation) level, in case any of
+   the fields themselves have nested structure, and SHOW is the number of
+   levels of internal structure to show (see ada_print_type).  For this
+   purpose, fields nested in a variant part are taken to be at the same
+   level as the fields immediately outside the variant part.  */
 
 static void
 print_variant_part (struct type *type, int field_num, struct type *outer_type,
@@ -549,14 +566,14 @@ print_variant_part (struct type *type, i
   fprintf_filtered (stream, "\n%*send case;", level + 4, "");
 }
 
-/* Print a description on STREAM of the fields in record type TYPE, whose 
-   discriminants are in OUTER_TYPE.  LEVEL is the recursion (indentation) 
-   level, in case any of the fields themselves have nested structure, 
-   and SHOW is the number of levels of internal structure to show 
-   (see ada_print_type).  Does not print parent type information of TYPE. 
-   Returns 0 if no fields printed, -1 for an incomplete type, else > 0. 
+/* Print a description on STREAM of the fields in record type TYPE, whose
+   discriminants are in OUTER_TYPE.  LEVEL is the recursion (indentation)
+   level, in case any of the fields themselves have nested structure,
+   and SHOW is the number of levels of internal structure to show
+   (see ada_print_type).  Does not print parent type information of TYPE.
+   Returns 0 if no fields printed, -1 for an incomplete type, else > 0.
    Prints each field beginning on a new line, but does not put a new line at
-   end. */
+   end.  */
 
 static int
 print_record_field_types (struct type *type, struct type *outer_type,
@@ -598,9 +615,9 @@ print_record_field_types (struct type *t
   return flds;
 }
 
-/* Print record type TYPE on STREAM.  LEVEL is the recursion (indentation) 
-   level, in case the element type itself has nested structure, and SHOW is 
-   the number of levels of internal structure to show (see ada_print_type). */
+/* Print record type TYPE on STREAM.  LEVEL is the recursion (indentation)
+   level, in case the element type itself has nested structure, and SHOW is
+   the number of levels of internal structure to show (see ada_print_type).  */
 
 static void
 print_record_type (struct type *type0, struct ui_file *stream, int show,
@@ -609,19 +626,15 @@ print_record_type (struct type *type0, s
   struct type *parent_type;
   struct type *type;
 
-  type = type0;
-  if (TYPE_FLAGS (type) & TYPE_FLAG_STUB)
-    {
-      struct type *type1 = ada_find_parallel_type (type, "___XVE");
-      if (type1 != NULL)
-	type = type1;
-    }
+  type = ada_find_parallel_type (type0, "___XVE");
+  if (type == NULL)
+    type = type0;
 
   parent_type = ada_parent_type (type);
   if (ada_type_name (parent_type) != NULL)
     fprintf_filtered (stream, "new %s with ",
-		      demangled_type_name (parent_type));
-  else if (parent_type == NULL && ada_is_tagged_type (type))
+		      decoded_type_name (parent_type));
+  else if (parent_type == NULL && ada_is_tagged_type (type, 0))
     fprintf_filtered (stream, "tagged ");
 
   fprintf_filtered (stream, "record");
@@ -648,9 +661,9 @@ print_record_type (struct type *type0, s
 }
 
 /* Print the unchecked union type TYPE in something resembling Ada
-   format on STREAM. LEVEL is the recursion (indentation) level
+   format on STREAM.  LEVEL is the recursion (indentation) level
    in case the element type itself has nested structure, and SHOW is the
-   number of levels of internal structure to show (see ada_print_type). */
+   number of levels of internal structure to show (see ada_print_type).  */
 static void
 print_unchecked_union_type (struct type *type, struct ui_file *stream,
 			    int show, int level)
@@ -685,7 +698,7 @@ print_unchecked_union_type (struct type 
 
 
 /* Print function or procedure type TYPE on STREAM.  Make it a header
-   for function or procedure NAME if NAME is not null. */
+   for function or procedure NAME if NAME is not null.  */
 
 static void
 print_func_type (struct type *type, struct ui_file *stream, char *name)
@@ -728,23 +741,21 @@ print_func_type (struct type *type, stru
    Output goes to STREAM (via stdio).
    If VARSTRING is a non-empty string, print as an Ada variable/field
        declaration.
-   SHOW+1 is the maximum number of levels of internal type structure 
+   SHOW+1 is the maximum number of levels of internal type structure
       to show (this applies to record types, enumerated types, and
       array types).
    SHOW is the number of levels of internal type structure to show
-      when there is a type name for the SHOWth deepest level (0th is 
+      when there is a type name for the SHOWth deepest level (0th is
       outer level).
    When SHOW<0, no inner structure is shown.
-   LEVEL indicates level of recursion (for nested definitions). */
+   LEVEL indicates level of recursion (for nested definitions).  */
 
 void
 ada_print_type (struct type *type0, char *varstring, struct ui_file *stream,
 		int show, int level)
 {
-  enum type_code code;
-  int demangled_args;
   struct type *type = ada_completed_type (ada_get_base_type (type0));
-  char *type_name = demangled_type_name (type);
+  char *type_name = decoded_type_name (type);
   int is_var_decl = (varstring != NULL && varstring[0] != '\0');
 
   if (type == NULL)
@@ -834,7 +845,7 @@ ada_print_type (struct type *type0, char
 	  print_enum_type (type, stream);
 	break;
       case TYPE_CODE_STRUCT:
-	if (ada_is_array_descriptor (type))
+	if (ada_is_array_descriptor_type (type))
 	  print_array_type (type, stream, show, level);
 	else if (ada_is_bogus_array_descriptor (type))
 	  fprintf_filtered (stream,
Index: gdb/ada-valprint.c
===================================================================
RCS file: /cvs/src/src/gdb/ada-valprint.c,v
retrieving revision 1.9
diff -u -p -r1.9 ada-valprint.c
--- gdb/ada-valprint.c	24 May 2003 03:21:42 -0000	1.9
+++ gdb/ada-valprint.c	2 Jun 2004 09:52:57 -0000
@@ -1,5 +1,6 @@
-/* Support for printing Ada values for GDB, the GNU debugger.  
-   Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1997, 2001
+/* Support for printing Ada values for GDB, the GNU debugger.
+   Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1997, 2001,
+   2002, 2003, 2004.
              Free Software Foundation, Inc.
 
 This file is part of GDB.
@@ -20,6 +21,7 @@ Foundation, Inc., 675 Mass Ave, Cambridg
 
 #include <ctype.h>
 #include "defs.h"
+#include "gdb_string.h"
 #include "symtab.h"
 #include "gdbtypes.h"
 #include "expression.h"
@@ -32,7 +34,7 @@ Foundation, Inc., 675 Mass Ave, Cambridg
 #include "c-lang.h"
 #include "infcall.h"
 
-/* Encapsulates arguments to ada_val_print. */
+/* Encapsulates arguments to ada_val_print.  */
 struct ada_val_print_args
 {
   struct type *type;
@@ -46,6 +48,9 @@ struct ada_val_print_args
   enum val_prettyprint pretty;
 };
 
+extern int inspect_it;
+extern unsigned int repeat_count_threshold;
+
 static void print_record (struct type *, char *, struct ui_file *, int,
 			  int, enum val_prettyprint);
 
@@ -64,14 +69,15 @@ static void val_print_packed_array_eleme
 
 static void adjust_type_signedness (struct type *);
 
-static int ada_val_print_stub (void *args0);
+static int ada_val_print_stub (PTR args0);
 
 static int ada_val_print_1 (struct type *, char *, int, CORE_ADDR,
 			    struct ui_file *, int, int, int,
 			    enum val_prettyprint);
+static void ada_print_floating (char *, struct type *, struct ui_file *);
 
 
-/* Make TYPE unsigned if its range of values includes no negatives. */
+/* Make TYPE unsigned if its range of values includes no negatives.  */
 static void
 adjust_type_signedness (struct type *type)
 {
@@ -82,8 +88,8 @@ adjust_type_signedness (struct type *typ
 
 /* Assuming TYPE is a simple array type, prints its lower bound on STREAM,
    if non-standard (i.e., other than 1 for numbers, other than lower bound
-   of index type for enumerated type). Returns 1 if something printed, 
-   otherwise 0. */
+   of index type for enumerated type).  Returns 1 if something printed,
+   otherwise 0.  */
 
 static int
 print_optional_low_bound (struct ui_file *stream, struct type *type)
@@ -127,8 +133,8 @@ print_optional_low_bound (struct ui_file
 /*  Version of val_print_array_elements for GNAT-style packed arrays.
     Prints elements of packed array of type TYPE at bit offset
     BITOFFSET from VALADDR on STREAM.  Formats according to FORMAT and
-    separates with commas. RECURSE is the recursion (nesting) level.
-    If PRETTY, uses "prettier" format. TYPE must have been decoded (as
+    separates with commas.  RECURSE is the recursion (nesting) level.
+    If PRETTY, uses "prettier" format.  TYPE must have been decoded (as
     by ada_coerce_to_simple_array).  */
 
 static void
@@ -142,11 +148,6 @@ val_print_packed_array_elements (struct 
   unsigned len;
   struct type *elttype;
   unsigned eltlen;
-  /* Position of the array element we are examining to see
-     whether it is repeated.  */
-  unsigned int rep1;
-  /* Number of repetitions we have detected so far.  */
-  unsigned int reps;
   unsigned long bitsize = TYPE_FIELD_BITSIZE (type, 0);
   struct value *mark = value_mark ();
 
@@ -252,7 +253,7 @@ printable_val_type (struct type *type, c
 
 /* Print the character C on STREAM as part of the contents of a literal
    string whose delimiter is QUOTER.  TYPE_LEN is the length in bytes
-   (1 or 2) of the character. */
+   (1 or 2) of the character.  */
 
 void
 ada_emit_char (int c, struct ui_file *stream, int quoter, int type_len)
@@ -274,7 +275,7 @@ ada_emit_char (int c, struct ui_file *st
 }
 
 /* Character #I of STRING, given that TYPE_LEN is the size in bytes (1
-   or 2) of a character. */
+   or 2) of a character.  */
 
 static int
 char_at (char *string, int i, int type_len)
@@ -285,6 +286,58 @@ char_at (char *string, int i, int type_l
     return (int) extract_unsigned_integer (string + 2 * i, 2);
 }
 
+/* Wrapper around memcpy to make it legal argument to ui_file_put */
+static void
+ui_memcpy (void *dest, const char *buffer, long len)
+{
+  memcpy (dest, buffer, (size_t) len);
+  ((char *) dest)[len] = '\0';
+}
+
+/* Print a floating-point value of type TYPE, pointed to in GDB by
+   VALADDR, on STREAM.  Use Ada formatting conventions: there must be
+   a decimal point, and at least one digit before and after the
+   point.  We use GNAT format for NaNs and infinities.  */
+static void
+ada_print_floating (char *valaddr, struct type *type, struct ui_file *stream)
+{
+  char buffer[64];
+  char *s, *result;
+  int len;
+  struct ui_file *tmp_stream = mem_fileopen ();
+  struct cleanup *cleanups = make_cleanup_ui_file_delete (tmp_stream);
+
+  print_floating (valaddr, type, tmp_stream);
+  ui_file_put (tmp_stream, ui_memcpy, buffer);
+  do_cleanups (cleanups);
+
+  result = buffer;
+  len = strlen (result);
+
+  /* Modify for Ada rules.  */
+  if ((s = strstr (result, "inf")) != NULL
+      || (s = strstr (result, "Inf")) != NULL
+      || (s = strstr (result, "INF")) != NULL)
+    strcpy (s, "Inf");
+  else if ((s = strstr (result, "nan")) != NULL
+	   || (s = strstr (result, "NaN")) != NULL
+	   || (s = strstr (result, "Nan")) != NULL)
+    {
+      s[0] = s[2] = 'N';
+      if (result[0] == '-')
+	result += 1;
+    }
+  else if (strchr (result, '.') == NULL)
+    {
+      if ((s = strchr (result, 'e')) == NULL)
+	fprintf_filtered (stream, "%s.0", result);
+      else
+	fprintf_filtered (stream, "%.*s.0%s", (int) (s-result), result, s);
+      return;
+    }
+  fprintf_filtered (stream, "%s", result);
+}
+
 void
 ada_printchar (int c, struct ui_file *stream)
 {
@@ -294,7 +347,7 @@ ada_printchar (int c, struct ui_file *st
 }
 
 /* [From print_type_scalar in typeprint.c].   Print VAL on STREAM in a
-   form appropriate for TYPE. */
+   form appropriate for TYPE.  */
 
 void
 ada_print_scalar (struct type *type, LONGEST val, struct ui_file *stream)
@@ -463,7 +516,7 @@ printstr (struct ui_file *stream, char *
 
 void
 ada_printstr (struct ui_file *stream, char *string, unsigned int length,
-	      int force_ellipses, int width)
+	      int width, int force_ellipses)
 {
   printstr (stream, string, length, force_ellipses, width);
 }
@@ -471,7 +524,7 @@ ada_printstr (struct ui_file *stream, ch
 
 /* Print data of type TYPE located at VALADDR (within GDB), which came from
    the inferior at address ADDRESS, onto stdio stream STREAM according to
-   FORMAT (a letter as for the printf % codes or 0 for natural format).  
+   FORMAT (a letter as for the printf % codes or 0 for natural format).
    The data at VALADDR is in target byte order.
 
    If the data is printed as a string, returns the number of string characters
@@ -508,9 +561,9 @@ ada_val_print (struct type *type, char *
 }
 
 /* Helper for ada_val_print; used as argument to catch_errors to
-   unmarshal the arguments to ada_val_print_1, which does the work. */
+   unmarshal the arguments to ada_val_print_1, which does the work.  */
 static int
-ada_val_print_stub (void * args0)
+ada_val_print_stub (PTR args0)
 {
   struct ada_val_print_args *argsp = (struct ada_val_print_args *) args0;
   return ada_val_print_1 (argsp->type, argsp->valaddr0,
@@ -520,7 +573,7 @@ ada_val_print_stub (void * args0)
 }
 
 /* See the comment on ada_val_print.  This function differs in that it
- * does not catch evaluation errors (leaving that to ada_val_print). */
+ * does not catch evaluation errors (leaving that to ada_val_print).  */
 
 static int
 ada_val_print_1 (struct type *type, char *valaddr0, int embedded_offset,
@@ -532,12 +585,11 @@ ada_val_print_1 (struct type *type, char
   struct type *elttype;
   unsigned int eltlen;
   LONGEST val;
-  CORE_ADDR addr;
   char *valaddr = valaddr0 + embedded_offset;
 
   CHECK_TYPEDEF (type);
 
-  if (ada_is_array_descriptor (type) || ada_is_packed_array_type (type))
+  if (ada_is_array_descriptor_type (type) || ada_is_packed_array_type (type))
     {
       int retn;
       struct value *mark = value_mark ();
@@ -567,6 +619,22 @@ ada_val_print_1 (struct type *type, char
       return c_val_print (type, valaddr0, embedded_offset, address, stream,
 			  format, deref_ref, recurse, pretty);
 
+    case TYPE_CODE_PTR:
+      {
+	int ret = c_val_print (type, valaddr0, embedded_offset, address, 
+			       stream, format, deref_ref, recurse, pretty);
+	if (ada_is_tag_type (type))
+	  {
+	    struct value *val = 
+	      value_from_contents_and_address (type, valaddr, address);
+	    const char *name = ada_tag_name (val);
+	    if (name != NULL) 
+	      fprintf_filtered (stream, " (%s)", name);
+	    return 0;
+	}
+	return ret;
+      }
+
     case TYPE_CODE_INT:
     case TYPE_CODE_RANGE:
       if (ada_is_fixed_point_type (type))
@@ -603,7 +671,7 @@ ada_val_print_1 (struct type *type, char
 	      fprintf_filtered (stream, "%s", VALUE_CONTENTS (printable_val));
 	      return 0;
 	    }
-	  /* No special printing function.  Do as best we can. */
+	  /* No special printing function.  Do as best we can.  */
 	}
       else if (TYPE_CODE (type) == TYPE_CODE_RANGE)
 	{
@@ -613,7 +681,7 @@ ada_val_print_1 (struct type *type, char
 	      /* Obscure case of range type that has different length from
 	         its base type.  Perform a conversion, or we will get a
 	         nonsense value.  Actually, we could use the same
-	         code regardless of lengths; I'm just avoiding a cast. */
+	         code regardless of lengths; I'm just avoiding a cast.  */
 	      struct value *v = value_cast (target_type,
 					    value_from_contents_and_address
 					    (type, valaddr, 0));
@@ -633,6 +701,20 @@ ada_val_print_1 (struct type *type, char
 	    {
 	      print_scalar_formatted (valaddr, type, format, 0, stream);
 	    }
+          else if (ada_is_system_address_type (type))
+            {
+              /* FIXME: We want to print System.Address variables using
+                 the same format as for any access type.  But for some
+                 reason GNAT encodes the System.Address type as an int,
+                 so we have to work-around this deficiency by handling
+                 System.Address values as a special case.  */
+              fprintf_filtered (stream, "(");
+              type_print (type, "", stream, -1);
+              fprintf_filtered (stream, ") ");
+              print_address_numeric 
+		(extract_typed_address (valaddr, builtin_type_void_data_ptr),
+                 1, stream);
+            }
 	  else
 	    {
 	      val_print_type_code_int (type, valaddr, stream);
@@ -676,6 +758,14 @@ ada_val_print_1 (struct type *type, char
 	}
       break;
 
+    case TYPE_CODE_FLT:
+      if (format)
+	return c_val_print (type, valaddr0, embedded_offset, address, stream,
+			    format, deref_ref, recurse, pretty);
+      else
+	ada_print_floating (valaddr0 + embedded_offset, type, stream);
+      break;
+
     case TYPE_CODE_UNION:
     case TYPE_CODE_STRUCT:
       if (ada_is_bogus_array_descriptor (type))
@@ -690,66 +780,60 @@ ada_val_print_1 (struct type *type, char
 	}
 
     case TYPE_CODE_ARRAY:
-      if (TYPE_LENGTH (type) > 0 && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0)
-	{
-	  elttype = TYPE_TARGET_TYPE (type);
-	  eltlen = TYPE_LENGTH (elttype);
-	  len = TYPE_LENGTH (type) / eltlen;
+      elttype = TYPE_TARGET_TYPE (type);
+      if (elttype == NULL)
+	eltlen = 0;
+      else
+	eltlen = TYPE_LENGTH (elttype);
+      /* FIXME: This doesn't deal with non-empty arrays of
+	 0-length items (not a typical case!) */
+      if (eltlen == 0)
+	len = 0;
+      else
+	len = TYPE_LENGTH (type) / eltlen;
 
 	  /* For an array of chars, print with string syntax.  */
-	  if (ada_is_string_type (type) && (format == 0 || format == 's'))
+      if (ada_is_string_type (type) && (format == 0 || format == 's'))
+	{
+	  if (prettyprint_arrays)
 	    {
-	      if (prettyprint_arrays)
-		{
-		  print_spaces_filtered (2 + 2 * recurse, stream);
-		}
-	      /* If requested, look for the first null char and only print
-	         elements up to it.  */
-	      if (stop_print_at_null)
-		{
-		  int temp_len;
-
-		  /* Look for a NULL char. */
-		  for (temp_len = 0;
-		       temp_len < len && temp_len < print_max
-		       && char_at (valaddr, temp_len, eltlen) != 0;
-		       temp_len += 1);
-		  len = temp_len;
-		}
-
-	      printstr (stream, valaddr, len, 0, eltlen);
+	      print_spaces_filtered (2 + 2 * recurse, stream);
 	    }
-	  else
+	  /* If requested, look for the first null char and only print
+	     elements up to it.  */
+	  if (stop_print_at_null)
 	    {
-	      len = 0;
-	      fprintf_filtered (stream, "(");
-	      print_optional_low_bound (stream, type);
-	      if (TYPE_FIELD_BITSIZE (type, 0) > 0)
-		val_print_packed_array_elements (type, valaddr, 0, stream,
-						 format, recurse, pretty);
-	      else
-		val_print_array_elements (type, valaddr, address, stream,
-					  format, deref_ref, recurse,
-					  pretty, 0);
-	      fprintf_filtered (stream, ")");
+	      int temp_len;
+
+	      /* Look for a NULL char.  */
+	      for (temp_len = 0;
+		   temp_len < len && temp_len < print_max
+		     && char_at (valaddr, temp_len, eltlen) != 0;
+		   temp_len += 1);
+	      len = temp_len;
 	    }
-	  gdb_flush (stream);
-	  return len;
+
+	  printstr (stream, valaddr, len, 0, eltlen);
+	}
+      else
+	{
+	  len = 0;
+	  fprintf_filtered (stream, "(");
+	  print_optional_low_bound (stream, type);
+	  if (TYPE_FIELD_BITSIZE (type, 0) > 0)
+	    val_print_packed_array_elements (type, valaddr, 0, stream,
+					     format, recurse, pretty);
+	  else
+	    val_print_array_elements (type, valaddr, address, stream,
+				      format, deref_ref, recurse,
+				      pretty, 0);
+	  fprintf_filtered (stream, ")");
 	}
+      gdb_flush (stream);
+      return len;
 
     case TYPE_CODE_REF:
       elttype = check_typedef (TYPE_TARGET_TYPE (type));
-      if (addressprint)
-	{
-	  fprintf_filtered (stream, "@");
-	  /* Extract an address, assume that the address is unsigned.  */
-	  print_address_numeric
-	    (extract_unsigned_integer (valaddr,
-				       TARGET_PTR_BIT / HOST_CHAR_BIT),
-	     1, stream);
-	  if (deref_ref)
-	    fputs_filtered (": ", stream);
-	}
       /* De-reference the reference */
       if (deref_ref)
 	{
@@ -777,6 +861,7 @@ ada_val_print_1 (struct type *type, char
 	}
       break;
     }
+  gdb_flush (stream);
   return 0;
 }
 
@@ -811,26 +896,21 @@ ada_value_print (struct value *val0, str
   struct value *val =
     value_from_contents_and_address (type, valaddr, address);
 
-  /* If it is a pointer, indicate what it points to. */
-  if (TYPE_CODE (type) == TYPE_CODE_PTR || TYPE_CODE (type) == TYPE_CODE_REF)
+  /* If it is a pointer, indicate what it points to.  */
+  if (TYPE_CODE (type) == TYPE_CODE_PTR)
     {
-      /* Hack:  remove (char *) for char strings.  Their
-         type is indicated by the quoted string anyway. */
-      if (TYPE_CODE (type) == TYPE_CODE_PTR &&
-	  TYPE_LENGTH (TYPE_TARGET_TYPE (type)) == sizeof (char) &&
-	  TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_INT &&
-	  !TYPE_UNSIGNED (TYPE_TARGET_TYPE (type)))
-	{
-	  /* Print nothing */
-	}
-      else
+      /* Hack:  don't print (char *) for char strings.  Their
+         type is indicated by the quoted string anyway.  */
+      if (TYPE_LENGTH (TYPE_TARGET_TYPE (type)) != sizeof (char)
+	  || TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_INT 
+	  || TYPE_UNSIGNED (TYPE_TARGET_TYPE (type)))
 	{
 	  fprintf_filtered (stream, "(");
 	  type_print (type, "", stream, -1);
 	  fprintf_filtered (stream, ") ");
 	}
     }
-  else if (ada_is_array_descriptor (type))
+  else if (ada_is_array_descriptor_type (type))
     {
       fprintf_filtered (stream, "(");
       type_print (type, "", stream, -1);
@@ -843,6 +923,23 @@ ada_value_print (struct value *val0, str
       fprintf_filtered (stream, ") (...?)");
       return 0;
     }
+
+  if (TYPE_CODE (type) == TYPE_CODE_ARRAY
+      && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) == 0
+      && TYPE_CODE (TYPE_INDEX_TYPE (type)) == TYPE_CODE_RANGE)
+    {
+      /* This is an array of zero-length elements, that is an array
+         of null records.  This array needs to be printed by hand,
+         as the standard routine to print arrays relies on the size of
+         the array elements to be nonzero.  This is because it computes
+         the number of elements in the array by dividing the array size
+         by the array element size.  */
+      fprintf_filtered (stream, "(%d .. %d => ())",
+                        TYPE_LOW_BOUND (TYPE_INDEX_TYPE (type)),
+                        TYPE_HIGH_BOUND (TYPE_INDEX_TYPE (type)));
+      return 0;
+    }
+  
   return (val_print (type, VALUE_CONTENTS (val), 0, address,
 		     stream, format, 1, 0, pretty));
 }
@@ -866,18 +963,18 @@ print_record (struct type *type, char *v
 }
 
 /* Print out fields of value at VALADDR having structure type TYPE.
-  
+
    TYPE, VALADDR, STREAM, FORMAT, RECURSE, and PRETTY have the
-   same meanings as in ada_print_value and ada_val_print.   
+   same meanings as in ada_print_value and ada_val_print.
 
    OUTER_TYPE and OUTER_VALADDR give type and address of enclosing record
    (used to get discriminant values when printing variant parts).
 
-   COMMA_NEEDED is 1 if fields have been printed at the current recursion 
+   COMMA_NEEDED is 1 if fields have been printed at the current recursion
    level, so that a comma is needed before any field printed by this
-   call. 
+   call.
 
-   Returns 1 if COMMA_NEEDED or any fields were printed. */
+   Returns 1 if COMMA_NEEDED or any fields were printed.  */
 
 static int
 print_field_values (struct type *type, char *valaddr, struct ui_file *stream,

