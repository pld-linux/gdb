http://sourceware.org/ml/gdb-patches/2010-08/msg00559.html
http://sourceware.org/ml/gdb-cvs/2010-08/msg00199.html

### src/gdb/ChangeLog	2010/08/31 18:08:42	1.12129
### src/gdb/ChangeLog	2010/08/31 18:11:48	1.12130
## -1,5 +1,14 @@
 2010-08-31  Jan Kratochvil  <jan.kratochvil@redhat.com>
 
+	Make linux_get_siginfo_type `type *' unique.
+	* linux-tdep.c (linux_gdbarch_data_handle, struct linux_gdbarch_data)
+	(init_linux_gdbarch_data, get_linux_gdbarch_data): New.
+	(linux_get_siginfo_type): New variable linux_gdbarch_data.  Initialize
+	it.  Use linux_gdbarch_data->siginfo_type as a persistent storage.
+	(_initialize_linux_tdep): New.
+
+2010-08-31  Jan Kratochvil  <jan.kratochvil@redhat.com>
+
 	Code cleanup.
 	* defs.h (find_memory_region_ftype): New typedef.
 	(exec_set_find_memory_regions): Use it.
Index: gdb-7.2/gdb/linux-tdep.c
===================================================================
--- gdb-7.2.orig/gdb/linux-tdep.c	2010-09-25 15:30:50.000000000 +0200
+++ gdb-7.2/gdb/linux-tdep.c	2010-09-25 15:31:54.000000000 +0200
@@ -26,18 +26,42 @@
 #include "value.h"
 #include "infcall.h"
 
+static struct gdbarch_data *linux_gdbarch_data_handle;
+
+struct linux_gdbarch_data
+  {
+    struct type *siginfo_type;
+  };
+
+static void *
+init_linux_gdbarch_data (struct gdbarch *gdbarch)
+{
+  return GDBARCH_OBSTACK_ZALLOC (gdbarch, struct linux_gdbarch_data);
+}
+
+static struct linux_gdbarch_data *
+get_linux_gdbarch_data (struct gdbarch *gdbarch)
+{
+  return gdbarch_data (gdbarch, linux_gdbarch_data_handle);
+}
+
 /* This function is suitable for architectures that don't
    extend/override the standard siginfo structure.  */
 
 struct type *
 linux_get_siginfo_type (struct gdbarch *gdbarch)
 {
+  struct linux_gdbarch_data *linux_gdbarch_data;
   struct type *int_type, *uint_type, *long_type, *void_ptr_type;
   struct type *uid_type, *pid_type;
   struct type *sigval_type, *clock_type;
   struct type *siginfo_type, *sifields_type;
   struct type *type;
 
+  linux_gdbarch_data = get_linux_gdbarch_data (gdbarch);
+  if (linux_gdbarch_data->siginfo_type != NULL)
+    return linux_gdbarch_data->siginfo_type;
+
   int_type = arch_integer_type (gdbarch, gdbarch_int_bit (gdbarch),
 			 	0, "int");
   uint_type = arch_integer_type (gdbarch, gdbarch_int_bit (gdbarch),
@@ -137,6 +161,8 @@ linux_get_siginfo_type (struct gdbarch *
 				       "_sifields", sifields_type,
 				       TYPE_LENGTH (long_type));
 
+  linux_gdbarch_data->siginfo_type = siginfo_type;
+
   return siginfo_type;
 }
 
@@ -154,3 +180,10 @@ linux_has_shared_address_space (void)
 
   return target_is_uclinux;
 }
+
+void
+_initialize_linux_tdep (void)
+{
+  linux_gdbarch_data_handle =
+    gdbarch_data_register_post_init (init_linux_gdbarch_data);
+}
