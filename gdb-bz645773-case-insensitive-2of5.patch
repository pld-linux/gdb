http://sourceware.org/ml/gdb-patches/2011-04/msg00124.html
Subject: [patch 1/3] case insensitive: Reformat code

Hi,

just some reformatting to make the later patch more clear.  There should be no
functionality difference by this patch.  c1+c2 are a bit ugly but I found any
other solution a bit ugly.


Thanks,
Jan


gdb/
2011-04-08  Jan Kratochvil  <jan.kratochvil@redhat.com>

	Format the code for the next patch.
	* dwarf2read.c (struct mapped_index): Include delimiting newlines.
	* utils.c (strcmp_iw_ordered): Reformat the code for the next patch.
	New variables c1 and c2.

--- a/gdb/dwarf2read.c
+++ b/gdb/dwarf2read.c
@@ -150,14 +150,19 @@ struct mapped_index
 {
   /* The total length of the buffer.  */
   off_t total_size;
+
   /* A pointer to the address table data.  */
   const gdb_byte *address_table;
+
   /* Size of the address table data in bytes.  */
   offset_type address_table_size;
+
   /* The symbol table, implemented as a hash table.  */
   const offset_type *symbol_table;
+
   /* Size in slots, each slot is 2 offset_types.  */
   offset_type symbol_table_slots;
+
   /* A pointer to the constant pool.  */
   const char *constant_pool;
 };
--- a/gdb/utils.c
+++ b/gdb/utils.c
@@ -3023,48 +3023,55 @@ strcmp_iw (const char *string1, const char *string2)
 int
 strcmp_iw_ordered (const char *string1, const char *string2)
 {
-  while ((*string1 != '\0') && (*string2 != '\0'))
+  /* Formatting stub.  */
+  if (1)
     {
-      while (isspace (*string1))
-	{
-	  string1++;
-	}
-      while (isspace (*string2))
-	{
-	  string2++;
-	}
-      if (*string1 != *string2)
+      /* C1 and C2 are valid only if *string1 != '\0' && *string2 != '\0'.
+	 Provide stub characters if we are already at the end of one of the
+	 strings.  */
+      char c1 = 'X', c2 = 'X';
+
+      while (*string1 != '\0' && *string2 != '\0')
 	{
-	  break;
+	  while (isspace (*string1))
+	    string1++;
+	  while (isspace (*string2))
+	    string2++;
+
+	      c1 = *string1;
+	      c2 = *string2;
+	  if (c1 != c2)
+	    break;
+
+	  if (*string1 != '\0')
+	    {
+	      string1++;
+	      string2++;
+	    }
 	}
-      if (*string1 != '\0')
+
+      switch (*string1)
 	{
-	  string1++;
-	  string2++;
+	  /* Characters are non-equal unless they're both '\0'; we want to
+	     make sure we get the comparison right according to our
+	     comparison in the cases where one of them is '\0' or '('.  */
+	case '\0':
+	  if (*string2 == '\0')
+	    return 0;
+	  else
+	    return -1;
+	case '(':
+	  if (*string2 == '\0')
+	    return 1;
+	  else
+	    return -1;
+	default:
+	  if (*string2 == '\0' || *string2 == '(')
+	    return 1;
+	  else
+	    return c1 - c2;
 	}
     }
-
-  switch (*string1)
-    {
-      /* Characters are non-equal unless they're both '\0'; we want to
-	 make sure we get the comparison right according to our
-	 comparison in the cases where one of them is '\0' or '('.  */
-    case '\0':
-      if (*string2 == '\0')
-	return 0;
-      else
-	return -1;
-    case '(':
-      if (*string2 == '\0')
-	return 1;
-      else
-	return -1;
-    default:
-      if (*string2 == '(')
-	return 1;
-      else
-	return *string1 - *string2;
-    }
 }
 
 /* A simple comparison function with opposite semantics to strcmp.  */

