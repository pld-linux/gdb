--- gdb-4.18/gdb/exec.c.sparc	Fri Jan  8 15:03:10 1999
+++ gdb-4.18/gdb/exec.c	Wed Apr 14 09:59:24 1999
@@ -536,11 +536,18 @@
 #endif /* 0, Stu's implementation */
   for (p = target->to_sections; p < target->to_sections_end; p++)
     {
+      int slop = 0;
+
+#if defined(__sparc__)
+      if (! strcmp (p->the_bfd_section->name, ".interp"))
+       slop = 32;
+#endif
+
       if (overlay_debugging && section && p->the_bfd_section &&
 	  strcmp (section->name, p->the_bfd_section->name) != 0)
 	continue;	/* not the section we need */
       if (memaddr >= p->addr)
- 	if (memend <= p->endaddr)
+ 	if (memend <= p->endaddr + slop)
 	  {
 	    /* Entire transfer is within this section.  */
 	    res = xfer_fn (p->bfd, p->the_bfd_section, myaddr,
--- gdb-4.18/bfd/section.c.sparc	Tue Jun 30 13:09:28 1998
+++ gdb-4.18/bfd/section.c	Wed Apr 14 09:59:24 1999
@@ -967,6 +967,7 @@
      bfd_size_type count;
 {
   bfd_size_type sz;
+  int slop = 0;
 
   if (section->flags & SEC_CONSTRUCTOR)
     {
@@ -982,7 +983,11 @@
     }
   /* Even if reloc_done is true, this function reads unrelocated
      contents, so we want the raw size.  */
-  sz = section->_raw_size;
+#if defined(__sparc__)
+  if (! strcmp (section->name, ".interp"))
+    slop = 32;
+#endif
+  sz = section->_raw_size + slop;
   if ((bfd_size_type) offset > sz || count > sz || offset + count > sz)
     goto bad_val;
 
--- gdb-4.18/bfd/libbfd.c.sparc	Thu Feb  4 21:29:32 1999
+++ gdb-4.18/bfd/libbfd.c	Wed Apr 14 09:59:24 1999
@@ -1152,9 +1152,14 @@
      file_ptr offset;
      bfd_size_type count;
 {
+    int slop = 0;
     if (count == 0)
         return true;
-    if ((bfd_size_type)(offset+count) > section->_raw_size
+#if defined(__sparc__)
+    if (! strcmp (section->name, ".interp"))
+      slop = 32;
+#endif
+    if ((bfd_size_type)(offset+count) > (section->_raw_size + slop)
         || bfd_seek(abfd, (file_ptr)(section->filepos + offset), SEEK_SET) == -1
         || bfd_read(location, (bfd_size_type)1, count, abfd) != count)
         return (false); /* on error */
