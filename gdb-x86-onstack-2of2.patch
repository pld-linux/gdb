http://sourceware.org/ml/gdb-patches/2012-03/msg00358.html
Subject: [patch 2/2] Fix gdb.cp/gdb2495.exp regression with gcc-4.7 #5

Hi,

here is the ON_STACK code again, with fixed alignment for i386 SSE.

It is generalized for all OSes on i386/amd64.  I can move it to
{i386,amd64)-linux-tdep.c but I find this code much more lightweight than
i386_push_dummy_call which is already present in i386-tdep.

No regressions on
{x86_64,x86_64-m32,i686}-fedora(15-rawhide)/rhel(5-6)-linux-gnu and for
gdbsever non-extended mode.

For x86_64-fedora17-linux-gnu it fixes:
-FAIL: gdb.cp/gdb2495.exp: Call a function that raises an exception without a handler.
-FAIL: gdb.cp/gdb2495.exp: bt after returning from a popped frame
+PASS: gdb.cp/gdb2495.exp: Call a function that raises an exception without a handler.
+PASS: gdb.cp/gdb2495.exp: bt after returning from a popped frame


Thanks,
Jan


gdb/
2012-03-09  Jan Kratochvil  <jan.kratochvil@redhat.com>

	* amd64-dicos-tdep.c (amd64_dicos_push_dummy_code): Remove.
	(amd64_dicos_init_abi): Remove its installment.
	* dicos-tdep.c (dicos_init_abi): Remove the
	set_gdbarch_call_dummy_location call.  Update the comment here.
	* i386-dicos-tdep.c (i386_dicos_push_dummy_code): Remove.
	(i386_dicos_init_abi): Remove its installment.
	* i386-tdep.c (i386_push_dummy_code): New function.
	(i386_gdbarch_init): Call set_gdbarch_call_dummy_location, install
	i386_push_dummy_code.

--- a/gdb/amd64-dicos-tdep.c
+++ b/gdb/amd64-dicos-tdep.c
@@ -23,24 +23,6 @@
 #include "amd64-tdep.h"
 #include "dicos-tdep.h"
 
-static CORE_ADDR
-amd64_dicos_push_dummy_code (struct gdbarch *gdbarch,
-			     CORE_ADDR sp, CORE_ADDR funaddr,
-			     struct value **args, int nargs,
-			     struct type *value_type,
-			     CORE_ADDR *real_pc, CORE_ADDR *bp_addr,
-			     struct regcache *regcache)
-{
-  int bplen;
-  CORE_ADDR bppc = sp;
-
-  gdbarch_breakpoint_from_pc (gdbarch, &bppc, &bplen);
-  *bp_addr = sp - bplen;
-  *real_pc = funaddr;
-
-  return *bp_addr;
-}
-
 static void
 amd64_dicos_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
 {
@@ -49,8 +31,6 @@ amd64_dicos_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
   amd64_init_abi (info, gdbarch);
 
   dicos_init_abi (gdbarch);
-
-  set_gdbarch_push_dummy_code (gdbarch, amd64_dicos_push_dummy_code);
 }
 
 static enum gdb_osabi
--- a/gdb/dicos-tdep.c
+++ b/gdb/dicos-tdep.c
@@ -43,8 +43,8 @@ dicos_init_abi (struct gdbarch *gdbarch)
 
   /* There's no (standard definition of) entry point or a guaranteed
      text location with a symbol where to place the call dummy, so we
-     put it on the stack.  */
-  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
+     need it on the stack.  Rely on i386_gdbarch_init used also for
+     amd64 to set up ON_STACK inferior calls.  */
 
   /* DICOS rewinds the PC itself.  */
   set_gdbarch_decr_pc_after_break (gdbarch, 0);
--- a/gdb/i386-dicos-tdep.c
+++ b/gdb/i386-dicos-tdep.c
@@ -22,32 +22,12 @@
 #include "gdb_string.h"
 #include "dicos-tdep.h"
 
-static CORE_ADDR
-i386_dicos_push_dummy_code (struct gdbarch *gdbarch,
-			    CORE_ADDR sp, CORE_ADDR funaddr,
-			    struct value **args, int nargs,
-			    struct type *value_type,
-			    CORE_ADDR *real_pc, CORE_ADDR *bp_addr,
-			    struct regcache *regcache)
-{
-  int bplen;
-  CORE_ADDR bppc = sp;
-
-  gdbarch_breakpoint_from_pc (gdbarch, &bppc, &bplen);
-  *bp_addr = sp - bplen;
-  *real_pc = funaddr;
-
-  return *bp_addr;
-}
-
 static void
 i386_dicos_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
 {
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
 
   dicos_init_abi (gdbarch);
-
-  set_gdbarch_push_dummy_code (gdbarch, i386_dicos_push_dummy_code);
 }
 
 static enum gdb_osabi
--- a/gdb/i386-tdep.c
+++ b/gdb/i386-tdep.c
@@ -2326,6 +2326,30 @@ i386_16_byte_align_p (struct type *type)
   return 0;
 }
 
+/* Implementation for set_gdbarch_push_dummy_code.  */
+
+static CORE_ADDR
+i386_push_dummy_code (struct gdbarch *gdbarch, CORE_ADDR sp, CORE_ADDR funaddr,
+		      struct value **args, int nargs, struct type *value_type,
+		      CORE_ADDR *real_pc, CORE_ADDR *bp_addr,
+		      struct regcache *regcache)
+{
+  int bplen;
+  CORE_ADDR bppc = sp;
+
+  gdbarch_breakpoint_from_pc (gdbarch, &bppc, &bplen);
+  sp -= bplen;
+
+  /* amd64_push_dummy_call does alignment on its own but i386_push_dummy_call
+     does not.  ABI requires stack alignment for executables using SSE.  */
+  if (gdbarch_frame_align_p (gdbarch))
+    sp = gdbarch_frame_align (gdbarch, sp);
+
+  *bp_addr = sp;
+  *real_pc = funaddr;
+  return sp;
+}
+
 static CORE_ADDR
 i386_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
 		      struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
@@ -7372,6 +7396,8 @@ i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
   set_gdbarch_get_longjmp_target (gdbarch, i386_get_longjmp_target);
 
   /* Call dummy code.  */
+  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
+  set_gdbarch_push_dummy_code (gdbarch, i386_push_dummy_code);
   set_gdbarch_push_dummy_call (gdbarch, i386_push_dummy_call);
   set_gdbarch_frame_align (gdbarch, i386_frame_align);
 

